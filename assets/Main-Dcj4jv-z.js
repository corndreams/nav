import { b as Zn, d as H, i as Xn, f as yn, u as Qn, a as se, c as bt, _ as q, e as ee, g as Qe, w as Ve, h as Ie, j as sr, k as ut, r as $t, l as ar } from "./base-ZOo04-Xo.js"; import { u as eo, E as to, t as yt } from "./el-scrollbar-CdrHRjxr.js"; import { i as Je, c as w, w as X, o as me, g as we, u as v, s as lr, r as P, a as ge, b as W, d as ir, p as ie, e as B, f as j, h as k, j as Q, n as ne, k as ot, N as Bt, l as Ke, m as ur, q as no, F as $e, T as cr, C as dr, t as K, v as Z, x as A, y as Ee, z as Pe, A as _t, B as Fe, D as pr, E as be, G as wt, H as Dt, I as fr, J as oo, K as vr, L as De, M as ue, O as He, P as mr, Q as gr, R as re, S as hr, U as br, V as ro, W as yr, X as Lt, Y as _r, Z as Ht, _ as le, $ as wr, a0 as Er, a1 as vt, a2 as Cr, a3 as Kt, a4 as Pt } from "./index-FQkZr4f5.js"; import { i as Ir, a as Te, t as Tr, u as so, o as Or, b as Sr, c as _n, d as Mr } from "./baseGet-DHzCPgPn.js"; import { f as wn, i as Ae, E as rt, a as jt, u as $r, T as Pr, m as Rr } from "./el-button-Dd2ozWxm.js"; import { u as ao, f as kr, _ as Ar, a as Fr, b as Nr } from "./user-ADi82P_-.js"; const mt = function (e, t, ...n) { let r; t.includes("mouse") || t.includes("click") ? r = "MouseEvents" : t.includes("key") ? r = "KeyboardEvent" : r = "HTMLEvents"; const o = document.createEvent(r); return o.initEvent(t, ...n), e.dispatchEvent(o), e }, te = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => o => { const s = e == null ? void 0 : e(o); if (n === !1 || !s) return t == null ? void 0 : t(o) }, En = e => t => t.pointerType === "mouse" ? e(t) : void 0; function Br() { if (!arguments.length) return []; var e = arguments[0]; return Ir(e) ? e : [e] } function et(e) { return e == null } function Lr(e) { return e === void 0 } const lo = (...e) => t => { e.forEach(n => { Je(n) ? n(t) : n.value = t }) }, Y = { tab: "Tab", enter: "Enter", space: "Space", left: "ArrowLeft", up: "ArrowUp", right: "ArrowRight", down: "ArrowDown", esc: "Escape", delete: "Delete", backspace: "Backspace", numpadEnter: "NumpadEnter", pageUp: "PageUp", pageDown: "PageDown", home: "Home", end: "End" }, xr = Zn({ type: H(Boolean), default: null }), Dr = Zn({ type: H(Function) }), io = e => { const t = `update:${e}`, n = `onUpdate:${e}`, r = [t], o = { [e]: xr, [n]: Dr }; return { useModelToggle: ({ indicator: a, toggleReason: l, shouldHideWhenRouteChanges: i, shouldProceed: u, onShow: d, onHide: g }) => { const b = we(), { emit: m } = b, c = b.props, f = w(() => Je(c[n])), y = w(() => c[e] === null), p = C => { a.value !== !0 && (a.value = !0, l && (l.value = C), Je(d) && d(C)) }, E = C => { a.value !== !1 && (a.value = !1, l && (l.value = C), Je(g) && g(C)) }, $ = C => { if (c.disabled === !0 || Je(u) && !u()) return; const R = f.value && Te; R && m(t, !0), (y.value || !R) && p(C) }, _ = C => { if (c.disabled === !0 || !Te) return; const R = f.value && Te; R && m(t, !1), (y.value || !R) && E(C) }, O = C => { Xn(C) && (c.disabled && C ? f.value && m(t, !1) : a.value !== C && (C ? p() : E())) }, S = () => { a.value ? _() : $() }; return X(() => c[e], O), i && b.appContext.config.globalProperties.$route !== void 0 && X(() => ({ ...b.proxy.$route }), () => { i.value && a.value && _() }), me(() => { O(c[e]) }), { hide: _, show: $, toggle: S, hasUpdateHandler: f } }, useModelToggleProps: o, useModelToggleEmits: r } }; io("modelValue"); var ce = "top", fe = "bottom", ve = "right", de = "left", zt = "auto", st = [ce, fe, ve, de], je = "start", tt = "end", Hr = "clippingParents", uo = "viewport", Ye = "popper", Kr = "reference", Cn = st.reduce(function (e, t) { return e.concat([t + "-" + je, t + "-" + tt]) }, []), Ut = [].concat(st, [zt]).reduce(function (e, t) { return e.concat([t, t + "-" + je, t + "-" + tt]) }, []), jr = "beforeRead", zr = "read", Ur = "afterRead", Wr = "beforeMain", Gr = "main", Vr = "afterMain", qr = "beforeWrite", Yr = "write", Jr = "afterWrite", Zr = [jr, zr, Ur, Wr, Gr, Vr, qr, Yr, Jr]; function Ce(e) { return e ? (e.nodeName || "").toLowerCase() : null } function ye(e) { if (e == null) return window; if (e.toString() !== "[object Window]") { var t = e.ownerDocument; return t && t.defaultView || window } return e } function ze(e) { var t = ye(e).Element; return e instanceof t || e instanceof Element } function pe(e) { var t = ye(e).HTMLElement; return e instanceof t || e instanceof HTMLElement } function Wt(e) { if (typeof ShadowRoot > "u") return !1; var t = ye(e).ShadowRoot; return e instanceof t || e instanceof ShadowRoot } function Xr(e) { var t = e.state; Object.keys(t.elements).forEach(function (n) { var r = t.styles[n] || {}, o = t.attributes[n] || {}, s = t.elements[n]; !pe(s) || !Ce(s) || (Object.assign(s.style, r), Object.keys(o).forEach(function (a) { var l = o[a]; l === !1 ? s.removeAttribute(a) : s.setAttribute(a, l === !0 ? "" : l) })) }) } function Qr(e) { var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach(function (r) { var o = t.elements[r], s = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), l = a.reduce(function (i, u) { return i[u] = "", i }, {}); !pe(o) || !Ce(o) || (Object.assign(o.style, l), Object.keys(s).forEach(function (i) { o.removeAttribute(i) })) }) } } var co = { name: "applyStyles", enabled: !0, phase: "write", fn: Xr, effect: Qr, requires: ["computeStyles"] }; function _e(e) { return e.split("-")[0] } var Ne = Math.max, Et = Math.min, Ue = Math.round; function We(e, t) { t === void 0 && (t = !1); var n = e.getBoundingClientRect(), r = 1, o = 1; if (pe(e) && t) { var s = e.offsetHeight, a = e.offsetWidth; a > 0 && (r = Ue(n.width) / a || 1), s > 0 && (o = Ue(n.height) / s || 1) } return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o } } function Gt(e) { var t = We(e), n = e.offsetWidth, r = e.offsetHeight; return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: r } } function po(e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && Wt(n)) { var r = t; do { if (r && e.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function Oe(e) { return ye(e).getComputedStyle(e) } function es(e) { return ["table", "td", "th"].indexOf(Ce(e)) >= 0 } function Re(e) { return ((ze(e) ? e.ownerDocument : e.document) || window.document).documentElement } function It(e) { return Ce(e) === "html" ? e : e.assignedSlot || e.parentNode || (Wt(e) ? e.host : null) || Re(e) } function In(e) { return !pe(e) || Oe(e).position === "fixed" ? null : e.offsetParent } function ts(e) { var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1; if (n && pe(e)) { var r = Oe(e); if (r.position === "fixed") return null } var o = It(e); for (Wt(o) && (o = o.host); pe(o) && ["html", "body"].indexOf(Ce(o)) < 0;) { var s = Oe(o); if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none") return o; o = o.parentNode } return null } function at(e) { for (var t = ye(e), n = In(e); n && es(n) && Oe(n).position === "static";)n = In(n); return n && (Ce(n) === "html" || Ce(n) === "body" && Oe(n).position === "static") ? t : n || ts(e) || t } function Vt(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function Ze(e, t, n) { return Ne(e, Et(t, n)) } function ns(e, t, n) { var r = Ze(e, t, n); return r > n ? n : r } function fo() { return { top: 0, right: 0, bottom: 0, left: 0 } } function vo(e) { return Object.assign({}, fo(), e) } function mo(e, t) { return t.reduce(function (n, r) { return n[r] = e, n }, {}) } var os = function (e, t) { return e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, vo(typeof e != "number" ? e : mo(e, st)) }; function rs(e) { var t, n = e.state, r = e.name, o = e.options, s = n.elements.arrow, a = n.modifiersData.popperOffsets, l = _e(n.placement), i = Vt(l), u = [de, ve].indexOf(l) >= 0, d = u ? "height" : "width"; if (!(!s || !a)) { var g = os(o.padding, n), b = Gt(s), m = i === "y" ? ce : de, c = i === "y" ? fe : ve, f = n.rects.reference[d] + n.rects.reference[i] - a[i] - n.rects.popper[d], y = a[i] - n.rects.reference[i], p = at(s), E = p ? i === "y" ? p.clientHeight || 0 : p.clientWidth || 0 : 0, $ = f / 2 - y / 2, _ = g[m], O = E - b[d] - g[c], S = E / 2 - b[d] / 2 + $, C = Ze(_, S, O), R = i; n.modifiersData[r] = (t = {}, t[R] = C, t.centerOffset = C - S, t) } } function ss(e) { var t = e.state, n = e.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r; o != null && (typeof o == "string" && (o = t.elements.popper.querySelector(o), !o) || !po(t.elements.popper, o) || (t.elements.arrow = o)) } var as = { name: "arrow", enabled: !0, phase: "main", fn: rs, effect: ss, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Ge(e) { return e.split("-")[1] } var ls = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function is(e) { var t = e.x, n = e.y, r = window, o = r.devicePixelRatio || 1; return { x: Ue(t * o) / o || 0, y: Ue(n * o) / o || 0 } } function Tn(e) { var t, n = e.popper, r = e.popperRect, o = e.placement, s = e.variation, a = e.offsets, l = e.position, i = e.gpuAcceleration, u = e.adaptive, d = e.roundOffsets, g = e.isFixed, b = a.x, m = b === void 0 ? 0 : b, c = a.y, f = c === void 0 ? 0 : c, y = typeof d == "function" ? d({ x: m, y: f }) : { x: m, y: f }; m = y.x, f = y.y; var p = a.hasOwnProperty("x"), E = a.hasOwnProperty("y"), $ = de, _ = ce, O = window; if (u) { var S = at(n), C = "clientHeight", R = "clientWidth"; if (S === ye(n) && (S = Re(n), Oe(S).position !== "static" && l === "absolute" && (C = "scrollHeight", R = "scrollWidth")), S = S, o === ce || (o === de || o === ve) && s === tt) { _ = fe; var L = g && S === O && O.visualViewport ? O.visualViewport.height : S[C]; f -= L - r.height, f *= i ? 1 : -1 } if (o === de || (o === ce || o === fe) && s === tt) { $ = ve; var x = g && S === O && O.visualViewport ? O.visualViewport.width : S[R]; m -= x - r.width, m *= i ? 1 : -1 } } var z = Object.assign({ position: l }, u && ls), D = d === !0 ? is({ x: m, y: f }) : { x: m, y: f }; if (m = D.x, f = D.y, i) { var G; return Object.assign({}, z, (G = {}, G[_] = E ? "0" : "", G[$] = p ? "0" : "", G.transform = (O.devicePixelRatio || 1) <= 1 ? "translate(" + m + "px, " + f + "px)" : "translate3d(" + m + "px, " + f + "px, 0)", G)) } return Object.assign({}, z, (t = {}, t[_] = E ? f + "px" : "", t[$] = p ? m + "px" : "", t.transform = "", t)) } function us(e) { var t = e.state, n = e.options, r = n.gpuAcceleration, o = r === void 0 ? !0 : r, s = n.adaptive, a = s === void 0 ? !0 : s, l = n.roundOffsets, i = l === void 0 ? !0 : l, u = { placement: _e(t.placement), variation: Ge(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: o, isFixed: t.options.strategy === "fixed" }; t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Tn(Object.assign({}, u, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: a, roundOffsets: i })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Tn(Object.assign({}, u, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: i })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) } var go = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: us, data: {} }, ct = { passive: !0 }; function cs(e) { var t = e.state, n = e.instance, r = e.options, o = r.scroll, s = o === void 0 ? !0 : o, a = r.resize, l = a === void 0 ? !0 : a, i = ye(t.elements.popper), u = [].concat(t.scrollParents.reference, t.scrollParents.popper); return s && u.forEach(function (d) { d.addEventListener("scroll", n.update, ct) }), l && i.addEventListener("resize", n.update, ct), function () { s && u.forEach(function (d) { d.removeEventListener("scroll", n.update, ct) }), l && i.removeEventListener("resize", n.update, ct) } } var ho = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: cs, data: {} }, ds = { left: "right", right: "left", bottom: "top", top: "bottom" }; function gt(e) { return e.replace(/left|right|bottom|top/g, function (t) { return ds[t] }) } var ps = { start: "end", end: "start" }; function On(e) { return e.replace(/start|end/g, function (t) { return ps[t] }) } function qt(e) { var t = ye(e), n = t.pageXOffset, r = t.pageYOffset; return { scrollLeft: n, scrollTop: r } } function Yt(e) { return We(Re(e)).left + qt(e).scrollLeft } function fs(e) { var t = ye(e), n = Re(e), r = t.visualViewport, o = n.clientWidth, s = n.clientHeight, a = 0, l = 0; return r && (o = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, l = r.offsetTop)), { width: o, height: s, x: a + Yt(e), y: l } } function vs(e) { var t, n = Re(e), r = qt(e), o = (t = e.ownerDocument) == null ? void 0 : t.body, s = Ne(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = Ne(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), l = -r.scrollLeft + Yt(e), i = -r.scrollTop; return Oe(o || n).direction === "rtl" && (l += Ne(n.clientWidth, o ? o.clientWidth : 0) - s), { width: s, height: a, x: l, y: i } } function Jt(e) { var t = Oe(e), n = t.overflow, r = t.overflowX, o = t.overflowY; return /auto|scroll|overlay|hidden/.test(n + o + r) } function bo(e) { return ["html", "body", "#document"].indexOf(Ce(e)) >= 0 ? e.ownerDocument.body : pe(e) && Jt(e) ? e : bo(It(e)) } function Xe(e, t) { var n; t === void 0 && (t = []); var r = bo(e), o = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = ye(r), a = o ? [s].concat(s.visualViewport || [], Jt(r) ? r : []) : r, l = t.concat(a); return o ? l : l.concat(Xe(It(a))) } function xt(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function ms(e) { var t = We(e); return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t } function Sn(e, t) { return t === uo ? xt(fs(e)) : ze(t) ? ms(t) : xt(vs(Re(e))) } function gs(e) { var t = Xe(It(e)), n = ["absolute", "fixed"].indexOf(Oe(e).position) >= 0, r = n && pe(e) ? at(e) : e; return ze(r) ? t.filter(function (o) { return ze(o) && po(o, r) && Ce(o) !== "body" }) : [] } function hs(e, t, n) { var r = t === "clippingParents" ? gs(e) : [].concat(t), o = [].concat(r, [n]), s = o[0], a = o.reduce(function (l, i) { var u = Sn(e, i); return l.top = Ne(u.top, l.top), l.right = Et(u.right, l.right), l.bottom = Et(u.bottom, l.bottom), l.left = Ne(u.left, l.left), l }, Sn(e, s)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function yo(e) { var t = e.reference, n = e.element, r = e.placement, o = r ? _e(r) : null, s = r ? Ge(r) : null, a = t.x + t.width / 2 - n.width / 2, l = t.y + t.height / 2 - n.height / 2, i; switch (o) { case ce: i = { x: a, y: t.y - n.height }; break; case fe: i = { x: a, y: t.y + t.height }; break; case ve: i = { x: t.x + t.width, y: l }; break; case de: i = { x: t.x - n.width, y: l }; break; default: i = { x: t.x, y: t.y } }var u = o ? Vt(o) : null; if (u != null) { var d = u === "y" ? "height" : "width"; switch (s) { case je: i[u] = i[u] - (t[d] / 2 - n[d] / 2); break; case tt: i[u] = i[u] + (t[d] / 2 - n[d] / 2); break } } return i } function nt(e, t) { t === void 0 && (t = {}); var n = t, r = n.placement, o = r === void 0 ? e.placement : r, s = n.boundary, a = s === void 0 ? Hr : s, l = n.rootBoundary, i = l === void 0 ? uo : l, u = n.elementContext, d = u === void 0 ? Ye : u, g = n.altBoundary, b = g === void 0 ? !1 : g, m = n.padding, c = m === void 0 ? 0 : m, f = vo(typeof c != "number" ? c : mo(c, st)), y = d === Ye ? Kr : Ye, p = e.rects.popper, E = e.elements[b ? y : d], $ = hs(ze(E) ? E : E.contextElement || Re(e.elements.popper), a, i), _ = We(e.elements.reference), O = yo({ reference: _, element: p, strategy: "absolute", placement: o }), S = xt(Object.assign({}, p, O)), C = d === Ye ? S : _, R = { top: $.top - C.top + f.top, bottom: C.bottom - $.bottom + f.bottom, left: $.left - C.left + f.left, right: C.right - $.right + f.right }, L = e.modifiersData.offset; if (d === Ye && L) { var x = L[o]; Object.keys(R).forEach(function (z) { var D = [ve, fe].indexOf(z) >= 0 ? 1 : -1, G = [ce, fe].indexOf(z) >= 0 ? "y" : "x"; R[z] += x[G] * D }) } return R } function bs(e, t) { t === void 0 && (t = {}); var n = t, r = n.placement, o = n.boundary, s = n.rootBoundary, a = n.padding, l = n.flipVariations, i = n.allowedAutoPlacements, u = i === void 0 ? Ut : i, d = Ge(r), g = d ? l ? Cn : Cn.filter(function (c) { return Ge(c) === d }) : st, b = g.filter(function (c) { return u.indexOf(c) >= 0 }); b.length === 0 && (b = g); var m = b.reduce(function (c, f) { return c[f] = nt(e, { placement: f, boundary: o, rootBoundary: s, padding: a })[_e(f)], c }, {}); return Object.keys(m).sort(function (c, f) { return m[c] - m[f] }) } function ys(e) { if (_e(e) === zt) return []; var t = gt(e); return [On(e), t, On(t)] } function _s(e) { var t = e.state, n = e.options, r = e.name; if (!t.modifiersData[r]._skip) { for (var o = n.mainAxis, s = o === void 0 ? !0 : o, a = n.altAxis, l = a === void 0 ? !0 : a, i = n.fallbackPlacements, u = n.padding, d = n.boundary, g = n.rootBoundary, b = n.altBoundary, m = n.flipVariations, c = m === void 0 ? !0 : m, f = n.allowedAutoPlacements, y = t.options.placement, p = _e(y), E = p === y, $ = i || (E || !c ? [gt(y)] : ys(y)), _ = [y].concat($).reduce(function (ae, he) { return ae.concat(_e(he) === zt ? bs(t, { placement: he, boundary: d, rootBoundary: g, padding: u, flipVariations: c, allowedAutoPlacements: f }) : he) }, []), O = t.rects.reference, S = t.rects.popper, C = new Map, R = !0, L = _[0], x = 0; x < _.length; x++) { var z = _[x], D = _e(z), G = Ge(z) === je, I = [ce, fe].indexOf(D) >= 0, T = I ? "width" : "height", M = nt(t, { placement: z, boundary: d, rootBoundary: g, altBoundary: b, padding: u }), h = I ? G ? ve : de : G ? fe : ce; O[T] > S[T] && (h = gt(h)); var F = gt(h), V = []; if (s && V.push(M[D] <= 0), l && V.push(M[h] <= 0, M[F] <= 0), V.every(function (ae) { return ae })) { L = z, R = !1; break } C.set(z, V) } if (R) for (var N = c ? 3 : 1, U = function (ae) { var he = _.find(function (lt) { var qe = C.get(lt); if (qe) return qe.slice(0, ae).every(function (Be) { return Be }) }); if (he) return L = he, "break" }, J = N; J > 0; J--) { var oe = U(J); if (oe === "break") break } t.placement !== L && (t.modifiersData[r]._skip = !0, t.placement = L, t.reset = !0) } } var ws = { name: "flip", enabled: !0, phase: "main", fn: _s, requiresIfExists: ["offset"], data: { _skip: !1 } }; function Mn(e, t, n) { return n === void 0 && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function $n(e) { return [ce, ve, fe, de].some(function (t) { return e[t] >= 0 }) } function Es(e) { var t = e.state, n = e.name, r = t.rects.reference, o = t.rects.popper, s = t.modifiersData.preventOverflow, a = nt(t, { elementContext: "reference" }), l = nt(t, { altBoundary: !0 }), i = Mn(a, r), u = Mn(l, o, s), d = $n(i), g = $n(u); t.modifiersData[n] = { referenceClippingOffsets: i, popperEscapeOffsets: u, isReferenceHidden: d, hasPopperEscaped: g }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": g }) } var Cs = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: Es }; function Is(e, t, n) { var r = _e(e), o = [de, ce].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n, a = s[0], l = s[1]; return a = a || 0, l = (l || 0) * o, [de, ve].indexOf(r) >= 0 ? { x: l, y: a } : { x: a, y: l } } function Ts(e) { var t = e.state, n = e.options, r = e.name, o = n.offset, s = o === void 0 ? [0, 0] : o, a = Ut.reduce(function (d, g) { return d[g] = Is(g, t.rects, s), d }, {}), l = a[t.placement], i = l.x, u = l.y; t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += i, t.modifiersData.popperOffsets.y += u), t.modifiersData[r] = a } var Os = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: Ts }; function Ss(e) { var t = e.state, n = e.name; t.modifiersData[n] = yo({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) } var _o = { name: "popperOffsets", enabled: !0, phase: "read", fn: Ss, data: {} }; function Ms(e) { return e === "x" ? "y" : "x" } function $s(e) { var t = e.state, n = e.options, r = e.name, o = n.mainAxis, s = o === void 0 ? !0 : o, a = n.altAxis, l = a === void 0 ? !1 : a, i = n.boundary, u = n.rootBoundary, d = n.altBoundary, g = n.padding, b = n.tether, m = b === void 0 ? !0 : b, c = n.tetherOffset, f = c === void 0 ? 0 : c, y = nt(t, { boundary: i, rootBoundary: u, padding: g, altBoundary: d }), p = _e(t.placement), E = Ge(t.placement), $ = !E, _ = Vt(p), O = Ms(_), S = t.modifiersData.popperOffsets, C = t.rects.reference, R = t.rects.popper, L = typeof f == "function" ? f(Object.assign({}, t.rects, { placement: t.placement })) : f, x = typeof L == "number" ? { mainAxis: L, altAxis: L } : Object.assign({ mainAxis: 0, altAxis: 0 }, L), z = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, D = { x: 0, y: 0 }; if (S) { if (s) { var G, I = _ === "y" ? ce : de, T = _ === "y" ? fe : ve, M = _ === "y" ? "height" : "width", h = S[_], F = h + y[I], V = h - y[T], N = m ? -R[M] / 2 : 0, U = E === je ? C[M] : R[M], J = E === je ? -R[M] : -C[M], oe = t.elements.arrow, ae = m && oe ? Gt(oe) : { width: 0, height: 0 }, he = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : fo(), lt = he[I], qe = he[T], Be = Ze(0, C[M], ae[M]), Xo = $ ? C[M] / 2 - N - Be - lt - x.mainAxis : U - Be - lt - x.mainAxis, Qo = $ ? -C[M] / 2 + N + Be + qe + x.mainAxis : J + Be + qe + x.mainAxis, St = t.elements.arrow && at(t.elements.arrow), er = St ? _ === "y" ? St.clientTop || 0 : St.clientLeft || 0 : 0, cn = (G = z == null ? void 0 : z[_]) != null ? G : 0, tr = h + Xo - cn - er, nr = h + Qo - cn, dn = Ze(m ? Et(F, tr) : F, h, m ? Ne(V, nr) : V); S[_] = dn, D[_] = dn - h } if (l) { var pn, or = _ === "x" ? ce : de, rr = _ === "x" ? fe : ve, ke = S[O], it = O === "y" ? "height" : "width", fn = ke + y[or], vn = ke - y[rr], Mt = [ce, de].indexOf(p) !== -1, mn = (pn = z == null ? void 0 : z[O]) != null ? pn : 0, gn = Mt ? fn : ke - C[it] - R[it] - mn + x.altAxis, hn = Mt ? ke + C[it] + R[it] - mn - x.altAxis : vn, bn = m && Mt ? ns(gn, ke, hn) : Ze(m ? gn : fn, ke, m ? hn : vn); S[O] = bn, D[O] = bn - ke } t.modifiersData[r] = D } } var Ps = { name: "preventOverflow", enabled: !0, phase: "main", fn: $s, requiresIfExists: ["offset"] }; function Rs(e) { return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } } function ks(e) { return e === ye(e) || !pe(e) ? qt(e) : Rs(e) } function As(e) { var t = e.getBoundingClientRect(), n = Ue(t.width) / e.offsetWidth || 1, r = Ue(t.height) / e.offsetHeight || 1; return n !== 1 || r !== 1 } function Fs(e, t, n) { n === void 0 && (n = !1); var r = pe(t), o = pe(t) && As(t), s = Re(t), a = We(e, o), l = { scrollLeft: 0, scrollTop: 0 }, i = { x: 0, y: 0 }; return (r || !r && !n) && ((Ce(t) !== "body" || Jt(s)) && (l = ks(t)), pe(t) ? (i = We(t, !0), i.x += t.clientLeft, i.y += t.clientTop) : s && (i.x = Yt(s))), { x: a.left + l.scrollLeft - i.x, y: a.top + l.scrollTop - i.y, width: a.width, height: a.height } } function Ns(e) { var t = new Map, n = new Set, r = []; e.forEach(function (s) { t.set(s.name, s) }); function o(s) { n.add(s.name); var a = [].concat(s.requires || [], s.requiresIfExists || []); a.forEach(function (l) { if (!n.has(l)) { var i = t.get(l); i && o(i) } }), r.push(s) } return e.forEach(function (s) { n.has(s.name) || o(s) }), r } function Bs(e) { var t = Ns(e); return Zr.reduce(function (n, r) { return n.concat(t.filter(function (o) { return o.phase === r })) }, []) } function Ls(e) { var t; return function () { return t || (t = new Promise(function (n) { Promise.resolve().then(function () { t = void 0, n(e()) }) })), t } } function xs(e) { var t = e.reduce(function (n, r) { var o = n[r.name]; return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n }, {}); return Object.keys(t).map(function (n) { return t[n] }) } var Pn = { placement: "bottom", modifiers: [], strategy: "absolute" }; function Rn() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some(function (r) { return !(r && typeof r.getBoundingClientRect == "function") }) } function Zt(e) { e === void 0 && (e = {}); var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, o = t.defaultOptions, s = o === void 0 ? Pn : o; return function (a, l, i) { i === void 0 && (i = s); var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Pn, s), modifiersData: {}, elements: { reference: a, popper: l }, attributes: {}, styles: {} }, d = [], g = !1, b = { state: u, setOptions: function (f) { var y = typeof f == "function" ? f(u.options) : f; c(), u.options = Object.assign({}, s, u.options, y), u.scrollParents = { reference: ze(a) ? Xe(a) : a.contextElement ? Xe(a.contextElement) : [], popper: Xe(l) }; var p = Bs(xs([].concat(r, u.options.modifiers))); return u.orderedModifiers = p.filter(function (E) { return E.enabled }), m(), b.update() }, forceUpdate: function () { if (!g) { var f = u.elements, y = f.reference, p = f.popper; if (Rn(y, p)) { u.rects = { reference: Fs(y, at(p), u.options.strategy === "fixed"), popper: Gt(p) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function (R) { return u.modifiersData[R.name] = Object.assign({}, R.data) }); for (var E = 0; E < u.orderedModifiers.length; E++) { if (u.reset === !0) { u.reset = !1, E = -1; continue } var $ = u.orderedModifiers[E], _ = $.fn, O = $.options, S = O === void 0 ? {} : O, C = $.name; typeof _ == "function" && (u = _({ state: u, options: S, name: C, instance: b }) || u) } } } }, update: Ls(function () { return new Promise(function (f) { b.forceUpdate(), f(u) }) }), destroy: function () { c(), g = !0 } }; if (!Rn(a, l)) return b; b.setOptions(i).then(function (f) { !g && i.onFirstUpdate && i.onFirstUpdate(f) }); function m() { u.orderedModifiers.forEach(function (f) { var y = f.name, p = f.options, E = p === void 0 ? {} : p, $ = f.effect; if (typeof $ == "function") { var _ = $({ state: u, name: y, instance: b, options: E }), O = function () { }; d.push(_ || O) } }) } function c() { d.forEach(function (f) { return f() }), d = [] } return b } } Zt(); var Ds = [ho, _o, go, co]; Zt({ defaultModifiers: Ds }); var Hs = [ho, _o, go, co, Os, ws, Ps, as, Cs], Ks = Zt({ defaultModifiers: Hs }); const js = (e, t, n = {}) => { const r = { name: "updateState", enabled: !0, phase: "write", fn: ({ state: i }) => { const u = zs(i); Object.assign(a.value, u) }, requires: ["computeStyles"] }, o = w(() => { const { onFirstUpdate: i, placement: u, strategy: d, modifiers: g } = v(n); return { onFirstUpdate: i, placement: u || "bottom", strategy: d || "absolute", modifiers: [...g || [], r, { name: "applyStyles", enabled: !1 }] } }), s = lr(), a = P({ styles: { popper: { position: v(o).strategy, left: "0", top: "0" }, arrow: { position: "absolute" } }, attributes: {} }), l = () => { s.value && (s.value.destroy(), s.value = void 0) }; return X(o, i => { const u = v(s); u && u.setOptions(i) }, { deep: !0 }), X([e, t], ([i, u]) => { l(), !(!i || !u) && (s.value = Ks(i, u, v(o))) }), ge(() => { l() }), { state: w(() => { var i; return { ...((i = v(s)) == null ? void 0 : i.state) || {} } }), styles: w(() => v(a).styles), attributes: w(() => v(a).attributes), update: () => { var i; return (i = v(s)) == null ? void 0 : i.update() }, forceUpdate: () => { var i; return (i = v(s)) == null ? void 0 : i.forceUpdate() }, instanceRef: w(() => v(s)) } }; function zs(e) { const t = Object.keys(e.elements), n = yn(t.map(o => [o, e.styles[o] || {}])), r = yn(t.map(o => [o, e.attributes[o]])); return { styles: n, attributes: r } } function kn() { let e; const t = (r, o) => { n(), e = window.setTimeout(r, o) }, n = () => window.clearTimeout(e); return Tr(() => n()), { registerTimeout: t, cancelTimeout: n } } const An = { prefix: Math.floor(Math.random() * 1e4), current: 0 }, Us = Symbol("elIdInjection"), wo = () => we() ? W(Us, An) : An, Xt = e => { const t = wo(), n = Qn(); return w(() => v(e) || `${n.value}-id-${t.prefix}-${t.current++}`) }; let xe = []; const Fn = e => { const t = e; t.key === Y.esc && xe.forEach(n => n(t)) }, Ws = e => { me(() => { xe.length === 0 && document.addEventListener("keydown", Fn), Te && xe.push(e) }), ge(() => { xe = xe.filter(t => t !== e), xe.length === 0 && Te && document.removeEventListener("keydown", Fn) }) }; let Nn; const Eo = () => { const e = Qn(), t = wo(), n = w(() => `${e.value}-popper-container-${t.prefix}`), r = w(() => `#${n.value}`); return { id: n, selector: r } }, Gs = e => { const t = document.createElement("div"); return t.id = e, document.body.appendChild(t), t }, Vs = () => { const { id: e, selector: t } = Eo(); return ir(() => { Te && !Nn && !document.body.querySelector(t.value) && (Nn = Gs(e.value)) }), { id: e, selector: t } }, qs = se({ showAfter: { type: Number, default: 0 }, hideAfter: { type: Number, default: 200 }, autoClose: { type: Number, default: 0 } }), Ys = ({ showAfter: e, hideAfter: t, autoClose: n, open: r, close: o }) => { const { registerTimeout: s } = kn(), { registerTimeout: a, cancelTimeout: l } = kn(); return { onOpen: d => { s(() => { r(d); const g = v(n); bt(g) && g > 0 && a(() => { o(d) }, g) }, v(e)) }, onClose: d => { l(), s(() => { o(d) }, v(t)) } } }, Co = Symbol("elForwardRef"), Js = e => { ie(Co, { setForwardRef: n => { e.value = n } }) }, Zs = e => ({ mounted(t) { e(t) }, updated(t) { e(t) }, unmounted() { e(null) } }), Bn = { current: 0 }, Ln = P(0), Xs = 2e3, xn = Symbol("elZIndexContextKey"), Qs = Symbol("zIndexContextKey"), ea = e => { const t = we() ? W(xn, Bn) : Bn, n = we() ? W(Qs, void 0) : void 0, r = w(() => { const a = v(n); return bt(a) ? a : Xs }), o = w(() => r.value + Ln.value), s = () => (t.current++, Ln.value = t.current, o.value); return !Te && W(xn), { initialZIndex: r, currentZIndex: o, nextZIndex: s } }, Qt = Symbol("popper"), Io = Symbol("popperContent"), ta = ["dialog", "grid", "group", "listbox", "menu", "navigation", "tooltip", "tree"], To = se({ role: { type: String, values: ta, default: "tooltip" } }), na = B({ name: "ElPopper", inheritAttrs: !1 }), oa = B({ ...na, props: To, setup(e, { expose: t }) { const n = e, r = P(), o = P(), s = P(), a = P(), l = w(() => n.role), i = { triggerRef: r, popperInstanceRef: o, contentRef: s, referenceRef: a, role: l }; return t(i), ie(Qt, i), (u, d) => j(u.$slots, "default") } }); var ra = q(oa, [["__file", "popper.vue"]]); const Oo = se({ arrowOffset: { type: Number, default: 5 } }), sa = B({ name: "ElPopperArrow", inheritAttrs: !1 }), aa = B({ ...sa, props: Oo, setup(e, { expose: t }) { const n = e, r = ee("popper"), { arrowOffset: o, arrowRef: s, arrowStyle: a } = W(Io, void 0); return X(() => n.arrowOffset, l => { o.value = l }), ge(() => { s.value = void 0 }), t({ arrowRef: s }), (l, i) => (k(), Q("span", { ref_key: "arrowRef", ref: s, class: ne(v(r).e("arrow")), style: ot(v(a)), "data-popper-arrow": "" }, null, 6)) } }); var la = q(aa, [["__file", "arrow.vue"]]); const ia = "ElOnlyChild", So = B({ name: ia, setup(e, { slots: t, attrs: n }) { var r; const o = W(Co), s = Zs((r = o == null ? void 0 : o.setForwardRef) != null ? r : Bt); return () => { var a; const l = (a = t.default) == null ? void 0 : a.call(t, n); if (!l || l.length > 1) return null; const i = Mo(l); return i ? Ke(ur(i, n), [[s]]) : null } } }); function Mo(e) { if (!e) return null; const t = e; for (const n of t) { if (no(n)) switch (n.type) { case dr: continue; case cr: case "svg": return Dn(n); case $e: return Mo(n.children); default: return n }return Dn(n) } return null } function Dn(e) { const t = ee("only-child"); return K("span", { class: t.e("content") }, [e]) } const $o = se({ virtualRef: { type: H(Object) }, virtualTriggering: Boolean, onMouseenter: { type: H(Function) }, onMouseleave: { type: H(Function) }, onClick: { type: H(Function) }, onKeydown: { type: H(Function) }, onFocus: { type: H(Function) }, onBlur: { type: H(Function) }, onContextmenu: { type: H(Function) }, id: String, open: Boolean }), ua = B({ name: "ElPopperTrigger", inheritAttrs: !1 }), ca = B({ ...ua, props: $o, setup(e, { expose: t }) { const n = e, { role: r, triggerRef: o } = W(Qt, void 0); Js(o); const s = w(() => l.value ? n.id : void 0), a = w(() => { if (r && r.value === "tooltip") return n.open && n.id ? n.id : void 0 }), l = w(() => { if (r && r.value !== "tooltip") return r.value }), i = w(() => l.value ? `${n.open}` : void 0); let u; return me(() => { X(() => n.virtualRef, d => { d && (o.value = so(d)) }, { immediate: !0 }), X(o, (d, g) => { u == null || u(), u = void 0, Qe(d) && (["onMouseenter", "onMouseleave", "onClick", "onKeydown", "onFocus", "onBlur", "onContextmenu"].forEach(b => { var m; const c = n[b]; c && (d.addEventListener(b.slice(2).toLowerCase(), c), (m = g == null ? void 0 : g.removeEventListener) == null || m.call(g, b.slice(2).toLowerCase(), c)) }), u = X([s, a, l, i], b => { ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach((m, c) => { et(b[c]) ? d.removeAttribute(m) : d.setAttribute(m, b[c]) }) }, { immediate: !0 })), Qe(g) && ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach(b => g.removeAttribute(b)) }, { immediate: !0 }) }), ge(() => { u == null || u(), u = void 0 }), t({ triggerRef: o }), (d, g) => d.virtualTriggering ? Pe("v-if", !0) : (k(), Z(v(So), Ee({ key: 0 }, d.$attrs, { "aria-controls": v(s), "aria-describedby": v(a), "aria-expanded": v(i), "aria-haspopup": v(l) }), { default: A(() => [j(d.$slots, "default")]), _: 3 }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) } }); var da = q(ca, [["__file", "trigger.vue"]]); const Rt = "focus-trap.focus-after-trapped", kt = "focus-trap.focus-after-released", pa = "focus-trap.focusout-prevented", Hn = { cancelable: !0, bubbles: !1 }, fa = { cancelable: !0, bubbles: !1 }, Kn = "focusAfterTrapped", jn = "focusAfterReleased", Po = Symbol("elFocusTrap"), en = P(), Tt = P(0), tn = P(0); let dt = 0; const Ro = e => { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const o = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t }, zn = (e, t) => { for (const n of e) if (!va(n, t)) return n }, va = (e, t) => { if (getComputedStyle(e).visibility === "hidden") return !0; for (; e;) { if (t && e === t) return !1; if (getComputedStyle(e).display === "none") return !0; e = e.parentElement } return !1 }, ma = e => { const t = Ro(e), n = zn(t, e), r = zn(t.reverse(), e); return [n, r] }, ga = e => e instanceof HTMLInputElement && "select" in e, Se = (e, t) => { if (e && e.focus) { const n = document.activeElement; e.focus({ preventScroll: !0 }), tn.value = window.performance.now(), e !== n && ga(e) && t && e.select() } }; function Un(e, t) { const n = [...e], r = e.indexOf(t); return r !== -1 && n.splice(r, 1), n } const ha = () => { let e = []; return { push: r => { const o = e[0]; o && r !== o && o.pause(), e = Un(e, r), e.unshift(r) }, remove: r => { var o, s; e = Un(e, r), (s = (o = e[0]) == null ? void 0 : o.resume) == null || s.call(o) } } }, ba = (e, t = !1) => { const n = document.activeElement; for (const r of e) if (Se(r, t), document.activeElement !== n) return }, Wn = ha(), ya = () => Tt.value > tn.value, pt = () => { en.value = "pointer", Tt.value = window.performance.now() }, Gn = () => { en.value = "keyboard", Tt.value = window.performance.now() }, _a = () => (me(() => { dt === 0 && (document.addEventListener("mousedown", pt), document.addEventListener("touchstart", pt), document.addEventListener("keydown", Gn)), dt++ }), ge(() => { dt--, dt <= 0 && (document.removeEventListener("mousedown", pt), document.removeEventListener("touchstart", pt), document.removeEventListener("keydown", Gn)) }), { focusReason: en, lastUserFocusTimestamp: Tt, lastAutomatedFocusTimestamp: tn }), ft = e => new CustomEvent(pa, { ...fa, detail: e }), wa = B({ name: "ElFocusTrap", inheritAttrs: !1, props: { loop: Boolean, trapped: Boolean, focusTrapEl: Object, focusStartEl: { type: [Object, String], default: "first" } }, emits: [Kn, jn, "focusin", "focusout", "focusout-prevented", "release-requested"], setup(e, { emit: t }) { const n = P(); let r, o; const { focusReason: s } = _a(); Ws(c => { e.trapped && !a.paused && t("release-requested", c) }); const a = { paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }, l = c => { if (!e.loop && !e.trapped || a.paused) return; const { key: f, altKey: y, ctrlKey: p, metaKey: E, currentTarget: $, shiftKey: _ } = c, { loop: O } = e, S = f === Y.tab && !y && !p && !E, C = document.activeElement; if (S && C) { const R = $, [L, x] = ma(R); if (L && x) { if (!_ && C === x) { const D = ft({ focusReason: s.value }); t("focusout-prevented", D), D.defaultPrevented || (c.preventDefault(), O && Se(L, !0)) } else if (_ && [L, R].includes(C)) { const D = ft({ focusReason: s.value }); t("focusout-prevented", D), D.defaultPrevented || (c.preventDefault(), O && Se(x, !0)) } } else if (C === R) { const D = ft({ focusReason: s.value }); t("focusout-prevented", D), D.defaultPrevented || c.preventDefault() } } }; ie(Po, { focusTrapRef: n, onKeydown: l }), X(() => e.focusTrapEl, c => { c && (n.value = c) }, { immediate: !0 }), X([n], ([c], [f]) => { c && (c.addEventListener("keydown", l), c.addEventListener("focusin", d), c.addEventListener("focusout", g)), f && (f.removeEventListener("keydown", l), f.removeEventListener("focusin", d), f.removeEventListener("focusout", g)) }); const i = c => { t(Kn, c) }, u = c => t(jn, c), d = c => { const f = v(n); if (!f) return; const y = c.target, p = c.relatedTarget, E = y && f.contains(y); e.trapped || p && f.contains(p) || (r = p), E && t("focusin", c), !a.paused && e.trapped && (E ? o = y : Se(o, !0)) }, g = c => { const f = v(n); if (!(a.paused || !f)) if (e.trapped) { const y = c.relatedTarget; !et(y) && !f.contains(y) && setTimeout(() => { if (!a.paused && e.trapped) { const p = ft({ focusReason: s.value }); t("focusout-prevented", p), p.defaultPrevented || Se(o, !0) } }, 0) } else { const y = c.target; y && f.contains(y) || t("focusout", c) } }; async function b() { await _t(); const c = v(n); if (c) { Wn.push(a); const f = c.contains(document.activeElement) ? r : document.activeElement; if (r = f, !c.contains(f)) { const p = new Event(Rt, Hn); c.addEventListener(Rt, i), c.dispatchEvent(p), p.defaultPrevented || _t(() => { let E = e.focusStartEl; Fe(E) || (Se(E), document.activeElement !== E && (E = "first")), E === "first" && ba(Ro(c), !0), (document.activeElement === f || E === "container") && Se(c) }) } } } function m() { const c = v(n); if (c) { c.removeEventListener(Rt, i); const f = new CustomEvent(kt, { ...Hn, detail: { focusReason: s.value } }); c.addEventListener(kt, u), c.dispatchEvent(f), !f.defaultPrevented && (s.value == "keyboard" || !ya() || c.contains(document.activeElement)) && Se(r ?? document.body), c.removeEventListener(kt, u), Wn.remove(a) } } return me(() => { e.trapped && b(), X(() => e.trapped, c => { c ? b() : m() }) }), ge(() => { e.trapped && m() }), { onKeydown: l } } }); function Ea(e, t, n, r, o, s) { return j(e.$slots, "default", { handleKeydown: e.onKeydown }) } var Ca = q(wa, [["render", Ea], ["__file", "focus-trap.vue"]]); const Ia = ["fixed", "absolute"], Ta = se({ boundariesPadding: { type: Number, default: 0 }, fallbackPlacements: { type: H(Array), default: void 0 }, gpuAcceleration: { type: Boolean, default: !0 }, offset: { type: Number, default: 12 }, placement: { type: String, values: Ut, default: "bottom" }, popperOptions: { type: H(Object), default: () => ({}) }, strategy: { type: String, values: Ia, default: "absolute" } }), ko = se({ ...Ta, id: String, style: { type: H([String, Array, Object]) }, className: { type: H([String, Array, Object]) }, effect: { type: String, default: "dark" }, visible: Boolean, enterable: { type: Boolean, default: !0 }, pure: Boolean, focusOnShow: { type: Boolean, default: !1 }, trapping: { type: Boolean, default: !1 }, popperClass: { type: H([String, Array, Object]) }, popperStyle: { type: H([String, Array, Object]) }, referenceEl: { type: H(Object) }, triggerTargetEl: { type: H(Object) }, stopPopperMouseEvent: { type: Boolean, default: !0 }, virtualTriggering: Boolean, zIndex: Number, ...eo(["ariaLabel"]) }), Oa = { mouseenter: e => e instanceof MouseEvent, mouseleave: e => e instanceof MouseEvent, focus: () => !0, blur: () => !0, close: () => !0 }, Sa = (e, t = []) => { const { placement: n, strategy: r, popperOptions: o } = e, s = { placement: n, strategy: r, ...o, modifiers: [...$a(e), ...t] }; return Pa(s, o == null ? void 0 : o.modifiers), s }, Ma = e => { if (Te) return so(e) }; function $a(e) { const { offset: t, gpuAcceleration: n, fallbackPlacements: r } = e; return [{ name: "offset", options: { offset: [0, t ?? 12] } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5, fallbackPlacements: r } }, { name: "computeStyles", options: { gpuAcceleration: n } }] } function Pa(e, t) { t && (e.modifiers = [...e.modifiers, ...t ?? []]) } const Ra = 0, ka = e => { const { popperInstanceRef: t, contentRef: n, triggerRef: r, role: o } = W(Qt, void 0), s = P(), a = P(), l = w(() => ({ name: "eventListeners", enabled: !!e.visible })), i = w(() => { var p; const E = v(s), $ = (p = v(a)) != null ? p : Ra; return { name: "arrow", enabled: !Lr(E), options: { element: E, padding: $ } } }), u = w(() => ({ onFirstUpdate: () => { c() }, ...Sa(e, [v(i), v(l)]) })), d = w(() => Ma(e.referenceEl) || v(r)), { attributes: g, state: b, styles: m, update: c, forceUpdate: f, instanceRef: y } = js(d, n, u); return X(y, p => t.value = p), me(() => { X(() => { var p; return (p = v(d)) == null ? void 0 : p.getBoundingClientRect() }, () => { c() }) }), { attributes: g, arrowRef: s, contentRef: n, instanceRef: y, state: b, styles: m, role: o, forceUpdate: f, update: c } }, Aa = (e, { attributes: t, styles: n, role: r }) => { const { nextZIndex: o } = ea(), s = ee("popper"), a = w(() => v(t).popper), l = P(bt(e.zIndex) ? e.zIndex : o()), i = w(() => [s.b(), s.is("pure", e.pure), s.is(e.effect), e.popperClass]), u = w(() => [{ zIndex: v(l) }, v(n).popper, e.popperStyle || {}]), d = w(() => r.value === "dialog" ? "false" : void 0), g = w(() => v(n).arrow || {}); return { ariaModal: d, arrowStyle: g, contentAttrs: a, contentClass: i, contentStyle: u, contentZIndex: l, updateZIndex: () => { l.value = bt(e.zIndex) ? e.zIndex : o() } } }, Fa = (e, t) => { const n = P(!1), r = P(); return { focusStartRef: r, trapped: n, onFocusAfterReleased: u => { var d; ((d = u.detail) == null ? void 0 : d.focusReason) !== "pointer" && (r.value = "first", t("blur")) }, onFocusAfterTrapped: () => { t("focus") }, onFocusInTrap: u => { e.visible && !n.value && (u.target && (r.value = u.target), n.value = !0) }, onFocusoutPrevented: u => { e.trapping || (u.detail.focusReason === "pointer" && u.preventDefault(), n.value = !1) }, onReleaseRequested: () => { n.value = !1, t("close") } } }, Na = B({ name: "ElPopperContent" }), Ba = B({ ...Na, props: ko, emits: Oa, setup(e, { expose: t, emit: n }) { const r = e, { focusStartRef: o, trapped: s, onFocusAfterReleased: a, onFocusAfterTrapped: l, onFocusInTrap: i, onFocusoutPrevented: u, onReleaseRequested: d } = Fa(r, n), { attributes: g, arrowRef: b, contentRef: m, styles: c, instanceRef: f, role: y, update: p } = ka(r), { ariaModal: E, arrowStyle: $, contentAttrs: _, contentClass: O, contentStyle: S, updateZIndex: C } = Aa(r, { styles: c, attributes: g, role: y }), R = W(wn, void 0), L = P(); ie(Io, { arrowStyle: $, arrowRef: b, arrowOffset: L }), R && ie(wn, { ...R, addInputId: Bt, removeInputId: Bt }); let x; const z = (G = !0) => { p(), G && C() }, D = () => { z(!1), r.visible && r.focusOnShow ? s.value = !0 : r.visible === !1 && (s.value = !1) }; return me(() => { X(() => r.triggerTargetEl, (G, I) => { x == null || x(), x = void 0; const T = v(G || m.value), M = v(I || m.value); Qe(T) && (x = X([y, () => r.ariaLabel, E, () => r.id], h => { ["role", "aria-label", "aria-modal", "id"].forEach((F, V) => { et(h[V]) ? T.removeAttribute(F) : T.setAttribute(F, h[V]) }) }, { immediate: !0 })), M !== T && Qe(M) && ["role", "aria-label", "aria-modal", "id"].forEach(h => { M.removeAttribute(h) }) }, { immediate: !0 }), X(() => r.visible, D, { immediate: !0 }) }), ge(() => { x == null || x(), x = void 0 }), t({ popperContentRef: m, popperInstanceRef: f, updatePopper: z, contentStyle: S }), (G, I) => (k(), Q("div", Ee({ ref_key: "contentRef", ref: m }, v(_), { style: v(S), class: v(O), tabindex: "-1", onMouseenter: I[0] || (I[0] = T => G.$emit("mouseenter", T)), onMouseleave: I[1] || (I[1] = T => G.$emit("mouseleave", T)) }), [K(v(Ca), { trapped: v(s), "trap-on-focus-in": !0, "focus-trap-el": v(m), "focus-start-el": v(o), onFocusAfterTrapped: v(l), onFocusAfterReleased: v(a), onFocusin: v(i), onFocusoutPrevented: v(u), onReleaseRequested: v(d) }, { default: A(() => [j(G.$slots, "default")]), _: 3 }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])], 16)) } }); var La = q(Ba, [["__file", "content.vue"]]); const xa = Ve(ra), nn = Symbol("elTooltip"), Ct = se({ ...qs, ...ko, appendTo: { type: H([String, Object]) }, content: { type: String, default: "" }, rawContent: { type: Boolean, default: !1 }, persistent: Boolean, visible: { type: H(Boolean), default: null }, transition: String, teleported: { type: Boolean, default: !0 }, disabled: Boolean, ...eo(["ariaLabel"]) }), on = se({ ...$o, disabled: Boolean, trigger: { type: H([String, Array]), default: "hover" }, triggerKeys: { type: H(Array), default: () => [Y.enter, Y.space] } }), { useModelToggleProps: Da, useModelToggleEmits: Ha, useModelToggle: Ka } = io("visible"), ja = se({ ...To, ...Da, ...Ct, ...on, ...Oo, showArrow: { type: Boolean, default: !0 } }), za = [...Ha, "before-show", "before-hide", "show", "hide", "open", "close"], Ua = (e, t) => pr(e) ? e.includes(t) : e === t, Le = (e, t, n) => r => { Ua(v(e), t) && n(r) }, Wa = B({ name: "ElTooltipTrigger" }), Ga = B({ ...Wa, props: on, setup(e, { expose: t }) { const n = e, r = ee("tooltip"), { controlled: o, id: s, open: a, onOpen: l, onClose: i, onToggle: u } = W(nn, void 0), d = P(null), g = () => { if (v(o) || n.disabled) return !0 }, b = be(n, "trigger"), m = te(g, Le(b, "hover", l)), c = te(g, Le(b, "hover", i)), f = te(g, Le(b, "click", _ => { _.button === 0 && u(_) })), y = te(g, Le(b, "focus", l)), p = te(g, Le(b, "focus", i)), E = te(g, Le(b, "contextmenu", _ => { _.preventDefault(), u(_) })), $ = te(g, _ => { const { code: O } = _; n.triggerKeys.includes(O) && (_.preventDefault(), u(_)) }); return t({ triggerRef: d }), (_, O) => (k(), Z(v(da), { id: v(s), "virtual-ref": _.virtualRef, open: v(a), "virtual-triggering": _.virtualTriggering, class: ne(v(r).e("trigger")), onBlur: v(p), onClick: v(f), onContextmenu: v(E), onFocus: v(y), onMouseenter: v(m), onMouseleave: v(c), onKeydown: v($) }, { default: A(() => [j(_.$slots, "default")]), _: 3 }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"])) } }); var Va = q(Ga, [["__file", "trigger.vue"]]); const qa = B({ name: "ElTooltipContent", inheritAttrs: !1 }), Ya = B({ ...qa, props: Ct, setup(e, { expose: t }) { const n = e, { selector: r } = Eo(), o = ee("tooltip"), s = P(null), a = P(!1), { controlled: l, id: i, open: u, trigger: d, onClose: g, onOpen: b, onShow: m, onHide: c, onBeforeShow: f, onBeforeHide: y } = W(nn, void 0), p = w(() => n.transition || `${o.namespace.value}-fade-in-linear`), E = w(() => n.persistent); ge(() => { a.value = !0 }); const $ = w(() => v(E) ? !0 : v(u)), _ = w(() => n.disabled ? !1 : v(u)), O = w(() => n.appendTo || r.value), S = w(() => { var h; return (h = n.style) != null ? h : {} }), C = w(() => !v(u)), R = () => { c() }, L = () => { if (v(l)) return !0 }, x = te(L, () => { n.enterable && v(d) === "hover" && b() }), z = te(L, () => { v(d) === "hover" && g() }), D = () => { var h, F; (F = (h = s.value) == null ? void 0 : h.updatePopper) == null || F.call(h), f == null || f() }, G = () => { y == null || y() }, I = () => { m(), M = Or(w(() => { var h; return (h = s.value) == null ? void 0 : h.popperContentRef }), () => { if (v(l)) return; v(d) !== "hover" && g() }) }, T = () => { n.virtualTriggering || g() }; let M; return X(() => v(u), h => { h || M == null || M() }, { flush: "post" }), X(() => n.content, () => { var h, F; (F = (h = s.value) == null ? void 0 : h.updatePopper) == null || F.call(h) }), t({ contentRef: s }), (h, F) => (k(), Z(fr, { disabled: !h.teleported, to: v(O) }, [K(Dt, { name: v(p), onAfterLeave: R, onBeforeEnter: D, onAfterEnter: I, onBeforeLeave: G }, { default: A(() => [v($) ? Ke((k(), Z(v(La), Ee({ key: 0, id: v(i), ref_key: "contentRef", ref: s }, h.$attrs, { "aria-label": h.ariaLabel, "aria-hidden": v(C), "boundaries-padding": h.boundariesPadding, "fallback-placements": h.fallbackPlacements, "gpu-acceleration": h.gpuAcceleration, offset: h.offset, placement: h.placement, "popper-options": h.popperOptions, strategy: h.strategy, effect: h.effect, enterable: h.enterable, pure: h.pure, "popper-class": h.popperClass, "popper-style": [h.popperStyle, v(S)], "reference-el": h.referenceEl, "trigger-target-el": h.triggerTargetEl, visible: v(_), "z-index": h.zIndex, onMouseenter: v(x), onMouseleave: v(z), onBlur: T, onClose: v(g) }), { default: A(() => [a.value ? Pe("v-if", !0) : j(h.$slots, "default", { key: 0 })]), _: 3 }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [[wt, v(_)]]) : Pe("v-if", !0)]), _: 3 }, 8, ["name"])], 8, ["disabled", "to"])) } }); var Ja = q(Ya, [["__file", "content.vue"]]); const Za = ["innerHTML"], Xa = { key: 1 }, Qa = B({ name: "ElTooltip" }), el = B({ ...Qa, props: ja, emits: za, setup(e, { expose: t, emit: n }) { const r = e; Vs(); const o = Xt(), s = P(), a = P(), l = () => { var p; const E = v(s); E && ((p = E.popperInstanceRef) == null || p.update()) }, i = P(!1), u = P(), { show: d, hide: g, hasUpdateHandler: b } = Ka({ indicator: i, toggleReason: u }), { onOpen: m, onClose: c } = Ys({ showAfter: be(r, "showAfter"), hideAfter: be(r, "hideAfter"), autoClose: be(r, "autoClose"), open: d, close: g }), f = w(() => Xn(r.visible) && !b.value); ie(nn, { controlled: f, id: o, open: oo(i), trigger: be(r, "trigger"), onOpen: p => { m(p) }, onClose: p => { c(p) }, onToggle: p => { v(i) ? c(p) : m(p) }, onShow: () => { n("show", u.value) }, onHide: () => { n("hide", u.value) }, onBeforeShow: () => { n("before-show", u.value) }, onBeforeHide: () => { n("before-hide", u.value) }, updatePopper: l }), X(() => r.disabled, p => { p && i.value && (i.value = !1) }); const y = p => { var E, $; const _ = ($ = (E = a.value) == null ? void 0 : E.contentRef) == null ? void 0 : $.popperContentRef, O = (p == null ? void 0 : p.relatedTarget) || document.activeElement; return _ && _.contains(O) }; return vr(() => i.value && g()), t({ popperRef: s, contentRef: a, isFocusInsideContent: y, updatePopper: l, onOpen: m, onClose: c, hide: g }), (p, E) => (k(), Z(v(xa), { ref_key: "popperRef", ref: s, role: p.role }, { default: A(() => [K(Va, { disabled: p.disabled, trigger: p.trigger, "trigger-keys": p.triggerKeys, "virtual-ref": p.virtualRef, "virtual-triggering": p.virtualTriggering }, { default: A(() => [p.$slots.default ? j(p.$slots, "default", { key: 0 }) : Pe("v-if", !0)]), _: 3 }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]), K(Ja, { ref_key: "contentRef", ref: a, "aria-label": p.ariaLabel, "boundaries-padding": p.boundariesPadding, content: p.content, disabled: p.disabled, effect: p.effect, enterable: p.enterable, "fallback-placements": p.fallbackPlacements, "hide-after": p.hideAfter, "gpu-acceleration": p.gpuAcceleration, offset: p.offset, persistent: p.persistent, "popper-class": p.popperClass, "popper-style": p.popperStyle, placement: p.placement, "popper-options": p.popperOptions, pure: p.pure, "raw-content": p.rawContent, "reference-el": p.referenceEl, "trigger-target-el": p.triggerTargetEl, "show-after": p.showAfter, strategy: p.strategy, teleported: p.teleported, transition: p.transition, "virtual-triggering": p.virtualTriggering, "z-index": p.zIndex, "append-to": p.appendTo }, { default: A(() => [j(p.$slots, "content", {}, () => [p.rawContent ? (k(), Q("span", { key: 0, innerHTML: p.content }, null, 8, Za)) : (k(), Q("span", Xa, De(p.content), 1))]), p.showArrow ? (k(), Z(v(la), { key: 0, "arrow-offset": p.arrowOffset }, null, 8, ["arrow-offset"])) : Pe("v-if", !0)]), _: 3 }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])]), _: 3 }, 8, ["role"])) } }); var tl = q(el, [["__file", "tooltip.vue"]]); const rn = Ve(tl), Ao = Symbol("breadcrumbKey"), nl = se({ separator: { type: String, default: "/" }, separatorIcon: { type: Ae } }), ol = ["aria-label"], rl = B({ name: "ElBreadcrumb" }), sl = B({ ...rl, props: nl, setup(e) { const t = e, { t: n } = ao(), r = ee("breadcrumb"), o = P(); return ie(Ao, t), me(() => { const s = o.value.querySelectorAll(`.${r.e("item")}`); s.length && s[s.length - 1].setAttribute("aria-current", "page") }), (s, a) => (k(), Q("div", { ref_key: "breadcrumb", ref: o, class: ne(v(r).b()), "aria-label": v(n)("el.breadcrumb.label"), role: "navigation" }, [j(s.$slots, "default")], 10, ol)) } }); var al = q(sl, [["__file", "breadcrumb.vue"]]); const ll = se({ to: { type: H([String, Object]), default: "" }, replace: { type: Boolean, default: !1 } }), il = B({ name: "ElBreadcrumbItem" }), ul = B({ ...il, props: ll, setup(e) { const t = e, n = we(), r = W(Ao, void 0), o = ee("breadcrumb"), s = n.appContext.config.globalProperties.$router, a = P(), l = () => { !t.to || !s || (t.replace ? s.replace(t.to) : s.push(t.to)) }; return (i, u) => { var d, g; return k(), Q("span", { class: ne(v(o).e("item")) }, [ue("span", { ref_key: "link", ref: a, class: ne([v(o).e("inner"), v(o).is("link", !!i.to)]), role: "link", onClick: l }, [j(i.$slots, "default")], 2), (d = v(r)) != null && d.separatorIcon ? (k(), Z(v(rt), { key: 0, class: ne(v(o).e("separator")) }, { default: A(() => [(k(), Z(He(v(r).separatorIcon)))]), _: 1 }, 8, ["class"])) : (k(), Q("span", { key: 1, class: ne(v(o).e("separator")), role: "presentation" }, De((g = v(r)) == null ? void 0 : g.separator), 3))], 2) } } }); var Fo = q(ul, [["__file", "breadcrumb-item.vue"]]); const cl = Ve(al, { BreadcrumbItem: Fo }), dl = Ie(Fo), Me = new Map; let Vn; Te && (document.addEventListener("mousedown", e => Vn = e), document.addEventListener("mouseup", e => { for (const t of Me.values()) for (const { documentHandler: n } of t) n(e, Vn) })); function qn(e, t) { let n = []; return Array.isArray(t.arg) ? n = t.arg : Qe(t.arg) && n.push(t.arg), function (r, o) { const s = t.instance.popperRef, a = r.target, l = o == null ? void 0 : o.target, i = !t || !t.instance, u = !a || !l, d = e.contains(a) || e.contains(l), g = e === a, b = n.length && n.some(c => c == null ? void 0 : c.contains(a)) || n.length && n.includes(l), m = s && (s.contains(a) || s.contains(l)); i || u || d || g || b || m || t.value(r, o) } } const pl = { beforeMount(e, t) { Me.has(e) || Me.set(e, []), Me.get(e).push({ documentHandler: qn(e, t), bindingFn: t.value }) }, updated(e, t) { Me.has(e) || Me.set(e, []); const n = Me.get(e), r = n.findIndex(s => s.bindingFn === t.oldValue), o = { documentHandler: qn(e, t), bindingFn: t.value }; r >= 0 ? n.splice(r, 1, o) : n.push(o) }, unmounted(e) { Me.delete(e) } }, fl = B({ name: "ElCollapseTransition" }), vl = B({ ...fl, setup(e) { const t = ee("collapse-transition"), n = o => { o.style.maxHeight = "", o.style.overflow = o.dataset.oldOverflow, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom }, r = { beforeEnter(o) { o.dataset || (o.dataset = {}), o.dataset.oldPaddingTop = o.style.paddingTop, o.dataset.oldPaddingBottom = o.style.paddingBottom, o.style.height && (o.dataset.elExistsHeight = o.style.height), o.style.maxHeight = 0, o.style.paddingTop = 0, o.style.paddingBottom = 0 }, enter(o) { requestAnimationFrame(() => { o.dataset.oldOverflow = o.style.overflow, o.dataset.elExistsHeight ? o.style.maxHeight = o.dataset.elExistsHeight : o.scrollHeight !== 0 ? o.style.maxHeight = `${o.scrollHeight}px` : o.style.maxHeight = 0, o.style.paddingTop = o.dataset.oldPaddingTop, o.style.paddingBottom = o.dataset.oldPaddingBottom, o.style.overflow = "hidden" }) }, afterEnter(o) { o.style.maxHeight = "", o.style.overflow = o.dataset.oldOverflow }, enterCancelled(o) { n(o) }, beforeLeave(o) { o.dataset || (o.dataset = {}), o.dataset.oldPaddingTop = o.style.paddingTop, o.dataset.oldPaddingBottom = o.style.paddingBottom, o.dataset.oldOverflow = o.style.overflow, o.style.maxHeight = `${o.scrollHeight}px`, o.style.overflow = "hidden" }, leave(o) { o.scrollHeight !== 0 && (o.style.maxHeight = 0, o.style.paddingTop = 0, o.style.paddingBottom = 0) }, afterLeave(o) { n(o) }, leaveCancelled(o) { n(o) } }; return (o, s) => (k(), Z(Dt, Ee({ name: v(t).b() }, mr(r)), { default: A(() => [j(o.$slots, "default")]), _: 3 }, 16, ["name"])) } }); var ht = q(vl, [["__file", "collapse-transition.vue"]]); ht.install = e => { e.component(ht.name, ht) }; const ml = ht, gl = B({ name: "ElContainer" }), hl = B({ ...gl, props: { direction: { type: String } }, setup(e) { const t = e, n = gr(), r = ee("container"), o = w(() => t.direction === "vertical" ? !0 : t.direction === "horizontal" ? !1 : n && n.default ? n.default().some(a => { const l = a.type.name; return l === "ElHeader" || l === "ElFooter" }) : !1); return (s, a) => (k(), Q("section", { class: ne([v(r).b(), v(r).is("vertical", v(o))]) }, [j(s.$slots, "default")], 2)) } }); var bl = q(hl, [["__file", "container.vue"]]); const yl = B({ name: "ElAside" }), _l = B({ ...yl, props: { width: { type: String, default: null } }, setup(e) { const t = e, n = ee("aside"), r = w(() => t.width ? n.cssVarBlock({ width: t.width }) : {}); return (o, s) => (k(), Q("aside", { class: ne(v(n).b()), style: ot(v(r)) }, [j(o.$slots, "default")], 6)) } }); var No = q(_l, [["__file", "aside.vue"]]); const wl = B({ name: "ElFooter" }), El = B({ ...wl, props: { height: { type: String, default: null } }, setup(e) { const t = e, n = ee("footer"), r = w(() => t.height ? n.cssVarBlock({ height: t.height }) : {}); return (o, s) => (k(), Q("footer", { class: ne(v(n).b()), style: ot(v(r)) }, [j(o.$slots, "default")], 6)) } }); var Bo = q(El, [["__file", "footer.vue"]]); const Cl = B({ name: "ElHeader" }), Il = B({ ...Cl, props: { height: { type: String, default: null } }, setup(e) { const t = e, n = ee("header"), r = w(() => t.height ? n.cssVarBlock({ height: t.height }) : {}); return (o, s) => (k(), Q("header", { class: ne(v(n).b()), style: ot(v(r)) }, [j(o.$slots, "default")], 6)) } }); var Lo = q(Il, [["__file", "header.vue"]]); const Tl = B({ name: "ElMain" }), Ol = B({ ...Tl, setup(e) { const t = ee("main"); return (n, r) => (k(), Q("main", { class: ne(v(t).b()) }, [j(n.$slots, "default")], 2)) } }); var xo = q(Ol, [["__file", "main.vue"]]); const Sl = Ve(bl, { Aside: No, Footer: Bo, Header: Lo, Main: xo }), Ml = Ie(No); Ie(Bo); const $l = Ie(Lo), Pl = Ie(xo), Rl = B({ inheritAttrs: !1 }); function kl(e, t, n, r, o, s) { return j(e.$slots, "default") } var Al = q(Rl, [["render", kl], ["__file", "collection.vue"]]); const Fl = B({ name: "ElCollectionItem", inheritAttrs: !1 }); function Nl(e, t, n, r, o, s) { return j(e.$slots, "default") } var Bl = q(Fl, [["render", Nl], ["__file", "collection-item.vue"]]); const Do = "data-el-collection-item", Ho = e => { const t = `El${e}Collection`, n = `${t}Item`, r = Symbol(t), o = Symbol(n), s = { ...Al, name: t, setup() { const l = P(null), i = new Map; ie(r, { itemMap: i, getItems: () => { const d = v(l); if (!d) return []; const g = Array.from(d.querySelectorAll(`[${Do}]`)); return [...i.values()].sort((m, c) => g.indexOf(m.ref) - g.indexOf(c.ref)) }, collectionRef: l }) } }, a = { ...Bl, name: n, setup(l, { attrs: i }) { const u = P(null), d = W(r, void 0); ie(o, { collectionItemRef: u }), me(() => { const g = v(u); g && d.itemMap.set(g, { ref: g, ...i }) }), ge(() => { const g = v(u); d.itemMap.delete(g) }) } }; return { COLLECTION_INJECTION_KEY: r, COLLECTION_ITEM_INJECTION_KEY: o, ElCollection: s, ElCollectionItem: a } }, Ll = se({ style: { type: H([String, Array, Object]) }, currentTabId: { type: H(String) }, defaultCurrentTabId: String, loop: Boolean, dir: { type: String, values: ["ltr", "rtl"], default: "ltr" }, orientation: { type: H(String) }, onBlur: Function, onFocus: Function, onMousedown: Function }), { ElCollection: xl, ElCollectionItem: Dl, COLLECTION_INJECTION_KEY: sn, COLLECTION_ITEM_INJECTION_KEY: Hl } = Ho("RovingFocusGroup"), an = Symbol("elRovingFocusGroup"), Ko = Symbol("elRovingFocusGroupItem"), Kl = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" }, jl = (e, t) => e, zl = (e, t, n) => { const r = jl(e.key); return Kl[r] }, Ul = (e, t) => e.map((n, r) => e[(r + t) % e.length]), ln = e => { const { activeElement: t } = document; for (const n of e) if (n === t || (n.focus(), t !== document.activeElement)) return }, Yn = "currentTabIdChange", Jn = "rovingFocusGroup.entryFocus", Wl = { bubbles: !1, cancelable: !0 }, Gl = B({ name: "ElRovingFocusGroupImpl", inheritAttrs: !1, props: Ll, emits: [Yn, "entryFocus"], setup(e, { emit: t }) { var n; const r = P((n = e.currentTabId || e.defaultCurrentTabId) != null ? n : null), o = P(!1), s = P(!1), a = P(null), { getItems: l } = W(sn, void 0), i = w(() => [{ outline: "none" }, e.style]), u = f => { t(Yn, f) }, d = () => { o.value = !0 }, g = te(f => { var y; (y = e.onMousedown) == null || y.call(e, f) }, () => { s.value = !0 }), b = te(f => { var y; (y = e.onFocus) == null || y.call(e, f) }, f => { const y = !v(s), { target: p, currentTarget: E } = f; if (p === E && y && !v(o)) { const $ = new Event(Jn, Wl); if (E == null || E.dispatchEvent($), !$.defaultPrevented) { const _ = l().filter(L => L.focusable), O = _.find(L => L.active), S = _.find(L => L.id === v(r)), R = [O, S, ..._].filter(Boolean).map(L => L.ref); ln(R) } } s.value = !1 }), m = te(f => { var y; (y = e.onBlur) == null || y.call(e, f) }, () => { o.value = !1 }), c = (...f) => { t("entryFocus", ...f) }; ie(an, { currentTabbedId: oo(r), loop: be(e, "loop"), tabIndex: w(() => v(o) ? -1 : 0), rovingFocusGroupRef: a, rovingFocusGroupRootStyle: i, orientation: be(e, "orientation"), dir: be(e, "dir"), onItemFocus: u, onItemShiftTab: d, onBlur: m, onFocus: b, onMousedown: g }), X(() => e.currentTabId, f => { r.value = f ?? null }), Sr(a, Jn, c) } }); function Vl(e, t, n, r, o, s) { return j(e.$slots, "default") } var ql = q(Gl, [["render", Vl], ["__file", "roving-focus-group-impl.vue"]]); const Yl = B({ name: "ElRovingFocusGroup", components: { ElFocusGroupCollection: xl, ElRovingFocusGroupImpl: ql } }); function Jl(e, t, n, r, o, s) { const a = re("el-roving-focus-group-impl"), l = re("el-focus-group-collection"); return k(), Z(l, null, { default: A(() => [K(a, hr(br(e.$attrs)), { default: A(() => [j(e.$slots, "default")]), _: 3 }, 16)]), _: 3 }) } var Zl = q(Yl, [["render", Jl], ["__file", "roving-focus-group.vue"]]); const Xl = B({ components: { ElRovingFocusCollectionItem: Dl }, props: { focusable: { type: Boolean, default: !0 }, active: { type: Boolean, default: !1 } }, emits: ["mousedown", "focus", "keydown"], setup(e, { emit: t }) { const { currentTabbedId: n, loop: r, onItemFocus: o, onItemShiftTab: s } = W(an, void 0), { getItems: a } = W(sn, void 0), l = Xt(), i = P(null), u = te(m => { t("mousedown", m) }, m => { e.focusable ? o(v(l)) : m.preventDefault() }), d = te(m => { t("focus", m) }, () => { o(v(l)) }), g = te(m => { t("keydown", m) }, m => { const { key: c, shiftKey: f, target: y, currentTarget: p } = m; if (c === Y.tab && f) { s(); return } if (y !== p) return; const E = zl(m); if (E) { m.preventDefault(); let _ = a().filter(O => O.focusable).map(O => O.ref); switch (E) { case "last": { _.reverse(); break } case "prev": case "next": { E === "prev" && _.reverse(); const O = _.indexOf(p); _ = r.value ? Ul(_, O + 1) : _.slice(O + 1); break } }_t(() => { ln(_) }) } }), b = w(() => n.value === v(l)); return ie(Ko, { rovingFocusGroupItemRef: i, tabIndex: w(() => v(b) ? 0 : -1), handleMousedown: u, handleFocus: d, handleKeydown: g }), { id: l, handleKeydown: g, handleFocus: d, handleMousedown: u } } }); function Ql(e, t, n, r, o, s) { const a = re("el-roving-focus-collection-item"); return k(), Z(a, { id: e.id, focusable: e.focusable, active: e.active }, { default: A(() => [j(e.$slots, "default")]), _: 3 }, 8, ["id", "focusable", "active"]) } var ei = q(Xl, [["render", Ql], ["__file", "roving-focus-item.vue"]]); const ti = se({ trigger: on.trigger, effect: { ...Ct.effect, default: "light" }, type: { type: H(String) }, placement: { type: H(String), default: "bottom" }, popperOptions: { type: H(Object), default: () => ({}) }, id: String, size: { type: String, default: "" }, splitButton: Boolean, hideOnClick: { type: Boolean, default: !0 }, loop: { type: Boolean, default: !0 }, showTimeout: { type: Number, default: 150 }, hideTimeout: { type: Number, default: 150 }, tabindex: { type: H([Number, String]), default: 0 }, maxHeight: { type: H([Number, String]), default: "" }, popperClass: { type: String, default: "" }, disabled: { type: Boolean, default: !1 }, role: { type: String, default: "menu" }, buttonProps: { type: H(Object) }, teleported: Ct.teleported }), jo = se({ command: { type: [Object, String, Number], default: () => ({}) }, disabled: Boolean, divided: Boolean, textValue: String, icon: { type: Ae } }), ni = se({ onKeydown: { type: H(Function) } }), oi = [Y.down, Y.pageDown, Y.home], zo = [Y.up, Y.pageUp, Y.end], ri = [...oi, ...zo], { ElCollection: si, ElCollectionItem: ai, COLLECTION_INJECTION_KEY: li, COLLECTION_ITEM_INJECTION_KEY: ii } = Ho("Dropdown"), Ot = Symbol("elDropdown"), { ButtonGroup: ui } = jt, ci = B({ name: "ElDropdown", components: { ElButton: jt, ElButtonGroup: ui, ElScrollbar: to, ElDropdownCollection: si, ElTooltip: rn, ElRovingFocusGroup: Zl, ElOnlyChild: So, ElIcon: rt, ArrowDown: ro }, props: ti, emits: ["visible-change", "click", "command"], setup(e, { emit: t }) { const n = we(), r = ee("dropdown"), { t: o } = ao(), s = P(), a = P(), l = P(null), i = P(null), u = P(null), d = P(null), g = P(!1), b = [Y.enter, Y.space, Y.down], m = w(() => ({ maxHeight: sr(e.maxHeight) })), c = w(() => [r.m(O.value)]), f = w(() => Br(e.trigger)), y = Xt().value, p = w(() => e.id || y); X([s, f], ([h, F], [V]) => { var N, U, J; (N = V == null ? void 0 : V.$el) != null && N.removeEventListener && V.$el.removeEventListener("pointerenter", C), (U = h == null ? void 0 : h.$el) != null && U.removeEventListener && h.$el.removeEventListener("pointerenter", C), (J = h == null ? void 0 : h.$el) != null && J.addEventListener && F.includes("hover") && h.$el.addEventListener("pointerenter", C) }, { immediate: !0 }), ge(() => { var h, F; (F = (h = s.value) == null ? void 0 : h.$el) != null && F.removeEventListener && s.value.$el.removeEventListener("pointerenter", C) }); function E() { $() } function $() { var h; (h = l.value) == null || h.onClose() } function _() { var h; (h = l.value) == null || h.onOpen() } const O = $r(); function S(...h) { t("command", ...h) } function C() { var h, F; (F = (h = s.value) == null ? void 0 : h.$el) == null || F.focus() } function R() { } function L() { const h = v(i); f.value.includes("hover") && (h == null || h.focus()), d.value = null } function x(h) { d.value = h } function z(h) { g.value || (h.preventDefault(), h.stopImmediatePropagation()) } function D() { t("visible-change", !0) } function G(h) { (h == null ? void 0 : h.type) === "keydown" && i.value.focus() } function I() { t("visible-change", !1) } return ie(Ot, { contentRef: i, role: w(() => e.role), triggerId: p, isUsingKeyboard: g, onItemEnter: R, onItemLeave: L }), ie("elDropdown", { instance: n, dropdownSize: O, handleClick: E, commandHandler: S, trigger: be(e, "trigger"), hideOnClick: be(e, "hideOnClick") }), { t: o, ns: r, scrollbar: u, wrapStyle: m, dropdownTriggerKls: c, dropdownSize: O, triggerId: p, triggerKeys: b, currentTabId: d, handleCurrentTabIdChange: x, handlerMainButtonClick: h => { t("click", h) }, handleEntryFocus: z, handleClose: $, handleOpen: _, handleBeforeShowTooltip: D, handleShowTooltip: G, handleBeforeHideTooltip: I, onFocusAfterTrapped: h => { var F, V; h.preventDefault(), (V = (F = i.value) == null ? void 0 : F.focus) == null || V.call(F, { preventScroll: !0 }) }, popperRef: l, contentRef: i, triggeringElementRef: s, referenceElementRef: a } } }); function di(e, t, n, r, o, s) { var a; const l = re("el-dropdown-collection"), i = re("el-roving-focus-group"), u = re("el-scrollbar"), d = re("el-only-child"), g = re("el-tooltip"), b = re("el-button"), m = re("arrow-down"), c = re("el-icon"), f = re("el-button-group"); return k(), Q("div", { class: ne([e.ns.b(), e.ns.is("disabled", e.disabled)]) }, [K(g, { ref: "popperRef", role: e.role, effect: e.effect, "fallback-placements": ["bottom", "top"], "popper-options": e.popperOptions, "gpu-acceleration": !1, "hide-after": e.trigger === "hover" ? e.hideTimeout : 0, "manual-mode": !0, placement: e.placement, "popper-class": [e.ns.e("popper"), e.popperClass], "reference-element": (a = e.referenceElementRef) == null ? void 0 : a.$el, trigger: e.trigger, "trigger-keys": e.triggerKeys, "trigger-target-el": e.contentRef, "show-after": e.trigger === "hover" ? e.showTimeout : 0, "stop-popper-mouse-event": !1, "virtual-ref": e.triggeringElementRef, "virtual-triggering": e.splitButton, disabled: e.disabled, transition: `${e.ns.namespace.value}-zoom-in-top`, teleported: e.teleported, pure: "", persistent: "", onBeforeShow: e.handleBeforeShowTooltip, onShow: e.handleShowTooltip, onBeforeHide: e.handleBeforeHideTooltip }, yr({ content: A(() => [K(u, { ref: "scrollbar", "wrap-style": e.wrapStyle, tag: "div", "view-class": e.ns.e("list") }, { default: A(() => [K(i, { loop: e.loop, "current-tab-id": e.currentTabId, orientation: "horizontal", onCurrentTabIdChange: e.handleCurrentTabIdChange, onEntryFocus: e.handleEntryFocus }, { default: A(() => [K(l, null, { default: A(() => [j(e.$slots, "dropdown")]), _: 3 })]), _: 3 }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange", "onEntryFocus"])]), _: 3 }, 8, ["wrap-style", "view-class"])]), _: 2 }, [e.splitButton ? void 0 : { name: "default", fn: A(() => [K(d, { id: e.triggerId, ref: "triggeringElementRef", role: "button", tabindex: e.tabindex }, { default: A(() => [j(e.$slots, "default")]), _: 3 }, 8, ["id", "tabindex"])]) }]), 1032, ["role", "effect", "popper-options", "hide-after", "placement", "popper-class", "reference-element", "trigger", "trigger-keys", "trigger-target-el", "show-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "onBeforeShow", "onShow", "onBeforeHide"]), e.splitButton ? (k(), Z(f, { key: 0 }, { default: A(() => [K(b, Ee({ ref: "referenceElementRef" }, e.buttonProps, { size: e.dropdownSize, type: e.type, disabled: e.disabled, tabindex: e.tabindex, onClick: e.handlerMainButtonClick }), { default: A(() => [j(e.$slots, "default")]), _: 3 }, 16, ["size", "type", "disabled", "tabindex", "onClick"]), K(b, Ee({ id: e.triggerId, ref: "triggeringElementRef" }, e.buttonProps, { role: "button", size: e.dropdownSize, type: e.type, class: e.ns.e("caret-button"), disabled: e.disabled, tabindex: e.tabindex, "aria-label": e.t("el.dropdown.toggleDropdown") }), { default: A(() => [K(c, { class: ne(e.ns.e("icon")) }, { default: A(() => [K(m)]), _: 1 }, 8, ["class"])]), _: 1 }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])]), _: 3 })) : Pe("v-if", !0)], 2) } var pi = q(ci, [["render", di], ["__file", "dropdown.vue"]]); const fi = B({ name: "DropdownItemImpl", components: { ElIcon: rt }, props: jo, emits: ["pointermove", "pointerleave", "click", "clickimpl"], setup(e, { emit: t }) { const n = ee("dropdown"), { role: r } = W(Ot, void 0), { collectionItemRef: o } = W(ii, void 0), { collectionItemRef: s } = W(Hl, void 0), { rovingFocusGroupItemRef: a, tabIndex: l, handleFocus: i, handleKeydown: u, handleMousedown: d } = W(Ko, void 0), g = lo(o, s, a), b = w(() => r.value === "menu" ? "menuitem" : r.value === "navigation" ? "link" : "button"), m = te(c => { const { code: f } = c; if (f === Y.enter || f === Y.space) return c.preventDefault(), c.stopImmediatePropagation(), t("clickimpl", c), !0 }, u); return { ns: n, itemRef: g, dataset: { [Do]: "" }, role: b, tabIndex: l, handleFocus: i, handleKeydown: m, handleMousedown: d } } }), vi = ["aria-disabled", "tabindex", "role"]; function mi(e, t, n, r, o, s) { const a = re("el-icon"); return k(), Q($e, null, [e.divided ? (k(), Q("li", Ee({ key: 0, role: "separator", class: e.ns.bem("menu", "item", "divided") }, e.$attrs), null, 16)) : Pe("v-if", !0), ue("li", Ee({ ref: e.itemRef }, { ...e.dataset, ...e.$attrs }, { "aria-disabled": e.disabled, class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)], tabindex: e.tabIndex, role: e.role, onClick: t[0] || (t[0] = l => e.$emit("clickimpl", l)), onFocus: t[1] || (t[1] = (...l) => e.handleFocus && e.handleFocus(...l)), onKeydown: t[2] || (t[2] = Lt((...l) => e.handleKeydown && e.handleKeydown(...l), ["self"])), onMousedown: t[3] || (t[3] = (...l) => e.handleMousedown && e.handleMousedown(...l)), onPointermove: t[4] || (t[4] = l => e.$emit("pointermove", l)), onPointerleave: t[5] || (t[5] = l => e.$emit("pointerleave", l)) }), [e.icon ? (k(), Z(a, { key: 0 }, { default: A(() => [(k(), Z(He(e.icon)))]), _: 1 })) : Pe("v-if", !0), j(e.$slots, "default")], 16, vi)], 64) } var gi = q(fi, [["render", mi], ["__file", "dropdown-item-impl.vue"]]); const Uo = () => { const e = W("elDropdown", {}), t = w(() => e == null ? void 0 : e.dropdownSize); return { elDropdown: e, _elDropdownSize: t } }, hi = B({ name: "ElDropdownItem", components: { ElDropdownCollectionItem: ai, ElRovingFocusItem: ei, ElDropdownItemImpl: gi }, inheritAttrs: !1, props: jo, emits: ["pointermove", "pointerleave", "click"], setup(e, { emit: t, attrs: n }) { const { elDropdown: r } = Uo(), o = we(), s = P(null), a = w(() => { var m, c; return (c = (m = v(s)) == null ? void 0 : m.textContent) != null ? c : "" }), { onItemEnter: l, onItemLeave: i } = W(Ot, void 0), u = te(m => (t("pointermove", m), m.defaultPrevented), En(m => { if (e.disabled) { i(m); return } const c = m.currentTarget; c === document.activeElement || c.contains(document.activeElement) || (l(m), m.defaultPrevented || c == null || c.focus()) })), d = te(m => (t("pointerleave", m), m.defaultPrevented), En(m => { i(m) })), g = te(m => { if (!e.disabled) return t("click", m), m.type !== "keydown" && m.defaultPrevented }, m => { var c, f, y; if (e.disabled) { m.stopImmediatePropagation(); return } (c = r == null ? void 0 : r.hideOnClick) != null && c.value && ((f = r.handleClick) == null || f.call(r)), (y = r.commandHandler) == null || y.call(r, e.command, o, m) }), b = w(() => ({ ...e, ...n })); return { handleClick: g, handlePointerMove: u, handlePointerLeave: d, textContent: a, propsAndAttrs: b } } }); function bi(e, t, n, r, o, s) { var a; const l = re("el-dropdown-item-impl"), i = re("el-roving-focus-item"), u = re("el-dropdown-collection-item"); return k(), Z(u, { disabled: e.disabled, "text-value": (a = e.textValue) != null ? a : e.textContent }, { default: A(() => [K(i, { focusable: !e.disabled }, { default: A(() => [K(l, Ee(e.propsAndAttrs, { onPointerleave: e.handlePointerLeave, onPointermove: e.handlePointerMove, onClickimpl: e.handleClick }), { default: A(() => [j(e.$slots, "default")]), _: 3 }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])]), _: 3 }, 8, ["focusable"])]), _: 3 }, 8, ["disabled", "text-value"]) } var Wo = q(hi, [["render", bi], ["__file", "dropdown-item.vue"]]); const yi = B({ name: "ElDropdownMenu", props: ni, setup(e) { const t = ee("dropdown"), { _elDropdownSize: n } = Uo(), r = n.value, { focusTrapRef: o, onKeydown: s } = W(Po, void 0), { contentRef: a, role: l, triggerId: i } = W(Ot, void 0), { collectionRef: u, getItems: d } = W(li, void 0), { rovingFocusGroupRef: g, rovingFocusGroupRootStyle: b, tabIndex: m, onBlur: c, onFocus: f, onMousedown: y } = W(an, void 0), { collectionRef: p } = W(sn, void 0), E = w(() => [t.b("menu"), t.bm("menu", r == null ? void 0 : r.value)]), $ = lo(a, u, o, g, p), _ = te(S => { var C; (C = e.onKeydown) == null || C.call(e, S) }, S => { const { currentTarget: C, code: R, target: L } = S; if (C.contains(L), Y.tab === R && S.stopImmediatePropagation(), S.preventDefault(), L !== v(a) || !ri.includes(R)) return; const z = d().filter(D => !D.disabled).map(D => D.ref); zo.includes(R) && z.reverse(), ln(z) }); return { size: r, rovingFocusGroupRootStyle: b, tabIndex: m, dropdownKls: E, role: l, triggerId: i, dropdownListWrapperRef: $, handleKeydown: S => { _(S), s(S) }, onBlur: c, onFocus: f, onMousedown: y } } }), _i = ["role", "aria-labelledby"]; function wi(e, t, n, r, o, s) { return k(), Q("ul", { ref: e.dropdownListWrapperRef, class: ne(e.dropdownKls), style: ot(e.rovingFocusGroupRootStyle), tabindex: -1, role: e.role, "aria-labelledby": e.triggerId, onBlur: t[0] || (t[0] = (...a) => e.onBlur && e.onBlur(...a)), onFocus: t[1] || (t[1] = (...a) => e.onFocus && e.onFocus(...a)), onKeydown: t[2] || (t[2] = Lt((...a) => e.handleKeydown && e.handleKeydown(...a), ["self"])), onMousedown: t[3] || (t[3] = Lt((...a) => e.onMousedown && e.onMousedown(...a), ["self"])) }, [j(e.$slots, "default")], 46, _i) } var Go = q(yi, [["render", wi], ["__file", "dropdown-menu.vue"]]); const Ei = Ve(pi, { DropdownItem: Wo, DropdownMenu: Go }), Ci = Ie(Wo), Ii = Ie(Go); let Ti = class { constructor(t, n) { this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init() } init() { this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners() } gotoSubIndex(t) { t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t } addListeners() { const t = this.parent.domNode; Array.prototype.forEach.call(this.subMenuItems, n => { n.addEventListener("keydown", r => { let o = !1; switch (r.code) { case Y.down: { this.gotoSubIndex(this.subIndex + 1), o = !0; break } case Y.up: { this.gotoSubIndex(this.subIndex - 1), o = !0; break } case Y.tab: { mt(t, "mouseleave"); break } case Y.enter: case Y.space: { o = !0, r.currentTarget.click(); break } }return o && (r.preventDefault(), r.stopPropagation()), !1 }) }) } }, Oi = class { constructor(t, n) { this.domNode = t, this.submenu = null, this.submenu = null, this.init(n) } init(t) { this.domNode.setAttribute("tabindex", "0"); const n = this.domNode.querySelector(`.${t}-menu`); n && (this.submenu = new Ti(this, n)), this.addListeners() } addListeners() { this.domNode.addEventListener("keydown", t => { let n = !1; switch (t.code) { case Y.down: { mt(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), n = !0; break } case Y.up: { mt(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), n = !0; break } case Y.tab: { mt(t.currentTarget, "mouseleave"); break } case Y.enter: case Y.space: { n = !0, t.currentTarget.click(); break } }n && t.preventDefault() }) } }, Si = class { constructor(t, n) { this.domNode = t, this.init(n) } init(t) { const n = this.domNode.childNodes; Array.from(n).forEach(r => { r.nodeType === 1 && new Oi(r, t) }) } }; const Mi = B({ name: "ElMenuCollapseTransition", setup() { const e = ee("menu"); return { listeners: { onBeforeEnter: n => n.style.opacity = "0.2", onEnter(n, r) { ut(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "1", r() }, onAfterEnter(n) { $t(n, `${e.namespace.value}-opacity-transition`), n.style.opacity = "" }, onBeforeLeave(n) { n.dataset || (n.dataset = {}), ar(n, e.m("collapse")) ? ($t(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), ut(n, e.m("collapse"))) : (ut(n, e.m("collapse")), n.dataset.oldOverflow = n.style.overflow, n.dataset.scrollWidth = n.clientWidth.toString(), $t(n, e.m("collapse"))), n.style.width = `${n.scrollWidth}px`, n.style.overflow = "hidden" }, onLeave(n) { ut(n, "horizontal-collapse-transition"), n.style.width = `${n.dataset.scrollWidth}px` } } } } }); function $i(e, t, n, r, o, s) { return k(), Z(Dt, Ee({ mode: "out-in" }, e.listeners), { default: A(() => [j(e.$slots, "default")]), _: 3 }, 16) } var Pi = q(Mi, [["render", $i], ["__file", "menu-collapse-transition.vue"]]); function Vo(e, t) { const n = w(() => { let o = e.parent; const s = [t.value]; for (; o.type.name !== "ElMenu";)o.props.index && s.unshift(o.props.index), o = o.parent; return s }); return { parentMenu: w(() => { let o = e.parent; for (; o && !["ElMenu", "ElSubMenu"].includes(o.type.name);)o = o.parent; return o }), indexPath: n } } function Ri(e) { return w(() => { const n = e.backgroundColor; return n ? new Pr(n).shade(20).toString() : "" }) } const qo = (e, t) => { const n = ee("menu"); return w(() => n.cssVarBlock({ "text-color": e.textColor || "", "hover-text-color": e.textColor || "", "bg-color": e.backgroundColor || "", "hover-bg-color": Ri(e).value || "", "active-color": e.activeTextColor || "", level: `${t}` })) }, ki = se({ index: { type: String, required: !0 }, showTimeout: Number, hideTimeout: Number, popperClass: String, disabled: Boolean, teleported: { type: Boolean, default: void 0 }, popperOffset: Number, expandCloseIcon: { type: Ae }, expandOpenIcon: { type: Ae }, collapseCloseIcon: { type: Ae }, collapseOpenIcon: { type: Ae } }), At = "ElSubMenu"; var un = B({ name: At, props: ki, setup(e, { slots: t, expose: n }) { const r = we(), { indexPath: o, parentMenu: s } = Vo(r, w(() => e.index)), a = ee("menu"), l = ee("sub-menu"), i = W("rootMenu"); i || yt(At, "can not inject root menu"); const u = W(`subMenu:${s.value.uid}`); u || yt(At, "can not inject sub menu"); const d = P({}), g = P({}); let b; const m = P(!1), c = P(), f = P(null), y = w(() => R.value === "horizontal" && E.value ? "bottom-start" : "right-start"), p = w(() => R.value === "horizontal" && E.value || R.value === "vertical" && !i.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? S.value ? e.expandOpenIcon : e.expandCloseIcon : ro : e.collapseCloseIcon && e.collapseOpenIcon ? S.value ? e.collapseOpenIcon : e.collapseCloseIcon : _r), E = w(() => u.level === 0), $ = w(() => { const N = e.teleported; return N === void 0 ? E.value : N }), _ = w(() => i.props.collapse ? `${a.namespace.value}-zoom-in-left` : `${a.namespace.value}-zoom-in-top`), O = w(() => R.value === "horizontal" && E.value ? ["bottom-start", "bottom-end", "top-start", "top-end", "right-start", "left-start"] : ["right-start", "right", "right-end", "left-start", "bottom-start", "bottom-end", "top-start", "top-end"]), S = w(() => i.openedMenus.includes(e.index)), C = w(() => { let N = !1; return Object.values(d.value).forEach(U => { U.active && (N = !0) }), Object.values(g.value).forEach(U => { U.active && (N = !0) }), N }), R = w(() => i.props.mode), L = Ht({ index: e.index, indexPath: o, active: C }), x = qo(i.props, u.level + 1), z = w(() => { var N; return (N = e.popperOffset) != null ? N : i.props.popperOffset }), D = w(() => { var N; return (N = e.popperClass) != null ? N : i.props.popperClass }), G = w(() => { var N; return (N = e.showTimeout) != null ? N : i.props.showTimeout }), I = w(() => { var N; return (N = e.hideTimeout) != null ? N : i.props.hideTimeout }), T = () => { var N, U, J; return (J = (U = (N = f.value) == null ? void 0 : N.popperRef) == null ? void 0 : U.popperInstanceRef) == null ? void 0 : J.destroy() }, M = N => { N || T() }, h = () => { i.props.menuTrigger === "hover" && i.props.mode === "horizontal" || i.props.collapse && i.props.mode === "vertical" || e.disabled || i.handleSubMenuClick({ index: e.index, indexPath: o.value, active: C.value }) }, F = (N, U = G.value) => { var J; if (N.type !== "focus") { if (i.props.menuTrigger === "click" && i.props.mode === "horizontal" || !i.props.collapse && i.props.mode === "vertical" || e.disabled) { u.mouseInChild.value = !0; return } u.mouseInChild.value = !0, b == null || b(), { stop: b } = _n(() => { i.openMenu(e.index, o.value) }, U), $.value && ((J = s.value.vnode.el) == null || J.dispatchEvent(new MouseEvent("mouseenter"))) } }, V = (N = !1) => { var U; if (i.props.menuTrigger === "click" && i.props.mode === "horizontal" || !i.props.collapse && i.props.mode === "vertical") { u.mouseInChild.value = !1; return } b == null || b(), u.mouseInChild.value = !1, { stop: b } = _n(() => !m.value && i.closeMenu(e.index, o.value), I.value), $.value && N && ((U = u.handleMouseleave) == null || U.call(u, !0)) }; X(() => i.props.collapse, N => M(!!N)); { const N = J => { g.value[J.index] = J }, U = J => { delete g.value[J.index] }; ie(`subMenu:${r.uid}`, { addSubMenu: N, removeSubMenu: U, handleMouseleave: V, mouseInChild: m, level: u.level + 1 }) } return n({ opened: S }), me(() => { i.addSubMenu(L), u.addSubMenu(L) }), ge(() => { u.removeSubMenu(L), i.removeSubMenu(L) }), () => { var N; const U = [(N = t.title) == null ? void 0 : N.call(t), le(rt, { class: l.e("icon-arrow"), style: { transform: S.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && i.props.collapse ? "none" : "rotateZ(180deg)" : "none" } }, { default: () => Fe(p.value) ? le(r.appContext.components[p.value]) : le(p.value) })], J = i.isMenuPopup ? le(rn, { ref: f, visible: S.value, effect: "light", pure: !0, offset: z.value, showArrow: !1, persistent: !0, popperClass: D.value, placement: y.value, teleported: $.value, fallbackPlacements: O.value, transition: _.value, gpuAcceleration: !1 }, { content: () => { var oe; return le("div", { class: [a.m(R.value), a.m("popup-container"), D.value], onMouseenter: ae => F(ae, 100), onMouseleave: () => V(!0), onFocus: ae => F(ae, 100) }, [le("ul", { class: [a.b(), a.m("popup"), a.m(`popup-${y.value}`)], style: x.value }, [(oe = t.default) == null ? void 0 : oe.call(t)])]) }, default: () => le("div", { class: l.e("title"), onClick: h }, U) }) : le($e, {}, [le("div", { class: l.e("title"), ref: c, onClick: h }, U), le(ml, {}, { default: () => { var oe; return Ke(le("ul", { role: "menu", class: [a.b(), a.m("inline")], style: x.value }, [(oe = t.default) == null ? void 0 : oe.call(t)]), [[wt, S.value]]) } })]); return le("li", { class: [l.b(), l.is("active", C.value), l.is("opened", S.value), l.is("disabled", e.disabled)], role: "menuitem", ariaHaspopup: !0, ariaExpanded: S.value, onMouseenter: F, onMouseleave: () => V(), onFocus: F }, [J]) } } }); const Ai = se({ mode: { type: String, values: ["horizontal", "vertical"], default: "vertical" }, defaultActive: { type: String, default: "" }, defaultOpeneds: { type: H(Array), default: () => Rr([]) }, uniqueOpened: Boolean, router: Boolean, menuTrigger: { type: String, values: ["hover", "click"], default: "hover" }, collapse: Boolean, backgroundColor: String, textColor: String, activeTextColor: String, closeOnClickOutside: Boolean, collapseTransition: { type: Boolean, default: !0 }, ellipsis: { type: Boolean, default: !0 }, popperOffset: { type: Number, default: 6 }, ellipsisIcon: { type: Ae, default: () => Er }, popperEffect: { type: String, values: ["dark", "light"], default: "dark" }, popperClass: String, showTimeout: { type: Number, default: 300 }, hideTimeout: { type: Number, default: 300 } }), Ft = e => Array.isArray(e) && e.every(t => Fe(t)), Fi = { close: (e, t) => Fe(e) && Ft(t), open: (e, t) => Fe(e) && Ft(t), select: (e, t, n, r) => Fe(e) && Ft(t) && no(n) && (r === void 0 || r instanceof Promise) }; var Ni = B({ name: "ElMenu", props: Ai, emits: Fi, setup(e, { emit: t, slots: n, expose: r }) { const o = we(), s = o.appContext.config.globalProperties.$router, a = P(), l = ee("menu"), i = ee("sub-menu"), u = P(-1), d = P(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []), g = P(e.defaultActive), b = P({}), m = P({}), c = w(() => e.mode === "horizontal" || e.mode === "vertical" && e.collapse), f = () => { const I = g.value && b.value[g.value]; if (!I || e.mode === "horizontal" || e.collapse) return; I.indexPath.forEach(M => { const h = m.value[M]; h && y(M, h.indexPath) }) }, y = (I, T) => { d.value.includes(I) || (e.uniqueOpened && (d.value = d.value.filter(M => T.includes(M))), d.value.push(I), t("open", I, T)) }, p = I => { const T = d.value.indexOf(I); T !== -1 && d.value.splice(T, 1) }, E = (I, T) => { p(I), t("close", I, T) }, $ = ({ index: I, indexPath: T }) => { d.value.includes(I) ? E(I, T) : y(I, T) }, _ = I => { (e.mode === "horizontal" || e.collapse) && (d.value = []); const { index: T, indexPath: M } = I; if (!(et(T) || et(M))) if (e.router && s) { const h = I.route || T, F = s.push(h).then(V => (V || (g.value = T), V)); t("select", T, M, { index: T, indexPath: M, route: h }, F) } else g.value = T, t("select", T, M, { index: T, indexPath: M }) }, O = I => { const T = b.value, M = T[I] || g.value && T[g.value] || T[e.defaultActive]; M ? g.value = M.index : g.value = I }, S = I => { const T = getComputedStyle(I), M = Number.parseInt(T.marginLeft, 10), h = Number.parseInt(T.marginRight, 10); return I.offsetWidth + M + h || 0 }, C = () => { var I, T; if (!a.value) return -1; const M = Array.from((T = (I = a.value) == null ? void 0 : I.childNodes) != null ? T : []).filter(ae => ae.nodeName !== "#comment" && (ae.nodeName !== "#text" || ae.nodeValue)), h = 64, F = getComputedStyle(a.value), V = Number.parseInt(F.paddingLeft, 10), N = Number.parseInt(F.paddingRight, 10), U = a.value.clientWidth - V - N; let J = 0, oe = 0; return M.forEach((ae, he) => { J += S(ae), J <= U - h && (oe = he + 1) }), oe === M.length ? -1 : oe }, R = I => m.value[I].indexPath, L = (I, T = 33.34) => { let M; return () => { M && clearTimeout(M), M = setTimeout(() => { I() }, T) } }; let x = !0; const z = () => { if (u.value === C()) return; const I = () => { u.value = -1, _t(() => { u.value = C() }) }; x ? I() : L(I)(), x = !1 }; X(() => e.defaultActive, I => { b.value[I] || (g.value = ""), O(I) }), X(() => e.collapse, I => { I && (d.value = []) }), X(b.value, f); let D; wr(() => { e.mode === "horizontal" && e.ellipsis ? D = Mr(a, z).stop : D == null || D() }); const G = P(!1); { const I = F => { m.value[F.index] = F }, T = F => { delete m.value[F.index] }; ie("rootMenu", Ht({ props: e, openedMenus: d, items: b, subMenus: m, activeIndex: g, isMenuPopup: c, addMenuItem: F => { b.value[F.index] = F }, removeMenuItem: F => { delete b.value[F.index] }, addSubMenu: I, removeSubMenu: T, openMenu: y, closeMenu: E, handleMenuItemClick: _, handleSubMenuClick: $ })), ie(`subMenu:${o.uid}`, { addSubMenu: I, removeSubMenu: T, mouseInChild: G, level: 0 }) } return me(() => { e.mode === "horizontal" && new Si(o.vnode.el, l.namespace.value) }), r({ open: T => { const { indexPath: M } = m.value[T]; M.forEach(h => y(h, M)) }, close: p, handleResize: z }), () => { var I, T; let M = (T = (I = n.default) == null ? void 0 : I.call(n)) != null ? T : []; const h = []; if (e.mode === "horizontal" && a.value) { const U = kr(M), J = u.value === -1 ? U : U.slice(0, u.value), oe = u.value === -1 ? [] : U.slice(u.value); oe != null && oe.length && e.ellipsis && (M = J, h.push(le(un, { index: "sub-menu-more", class: i.e("hide-arrow"), popperOffset: e.popperOffset }, { title: () => le(rt, { class: i.e("icon-more") }, { default: () => le(e.ellipsisIcon) }), default: () => oe }))) } const F = qo(e, 0), V = e.closeOnClickOutside ? [[pl, () => { d.value.length && (G.value || (d.value.forEach(U => t("close", U, R(U))), d.value = [])) }]] : [], N = Ke(le("ul", { key: String(e.collapse), role: "menubar", ref: a, style: F.value, class: { [l.b()]: !0, [l.m(e.mode)]: !0, [l.m("collapse")]: e.collapse } }, [...M, ...h]), V); return e.collapseTransition && e.mode === "vertical" ? le(Pi, () => N) : N } } }); const Bi = se({ index: { type: H([String, null]), default: null }, route: { type: H([String, Object]) }, disabled: Boolean }), Li = { click: e => Fe(e.index) && Array.isArray(e.indexPath) }, Nt = "ElMenuItem", xi = B({ name: Nt, components: { ElTooltip: rn }, props: Bi, emits: Li, setup(e, { emit: t }) { const n = we(), r = W("rootMenu"), o = ee("menu"), s = ee("menu-item"); r || yt(Nt, "can not inject root menu"); const { parentMenu: a, indexPath: l } = Vo(n, be(e, "index")), i = W(`subMenu:${a.value.uid}`); i || yt(Nt, "can not inject sub menu"); const u = w(() => e.index === r.activeIndex), d = Ht({ index: e.index, indexPath: l, active: u }), g = () => { e.disabled || (r.handleMenuItemClick({ index: e.index, indexPath: l.value, route: e.route }), t("click", d)) }; return me(() => { i.addSubMenu(d), r.addMenuItem(d) }), ge(() => { i.removeSubMenu(d), r.removeMenuItem(d) }), { parentMenu: a, rootMenu: r, active: u, nsMenu: o, nsMenuItem: s, handleClick: g } } }); function Di(e, t, n, r, o, s) { const a = re("el-tooltip"); return k(), Q("li", { class: ne([e.nsMenuItem.b(), e.nsMenuItem.is("active", e.active), e.nsMenuItem.is("disabled", e.disabled)]), role: "menuitem", tabindex: "-1", onClick: t[0] || (t[0] = (...l) => e.handleClick && e.handleClick(...l)) }, [e.parentMenu.type.name === "ElMenu" && e.rootMenu.props.collapse && e.$slots.title ? (k(), Z(a, { key: 0, effect: e.rootMenu.props.popperEffect, placement: "right", "fallback-placements": ["left"], persistent: "" }, { content: A(() => [j(e.$slots, "title")]), default: A(() => [ue("div", { class: ne(e.nsMenu.be("tooltip", "trigger")) }, [j(e.$slots, "default")], 2)]), _: 3 }, 8, ["effect"])) : (k(), Q($e, { key: 1 }, [j(e.$slots, "default"), j(e.$slots, "title")], 64))], 2) } var Yo = q(xi, [["render", Di], ["__file", "menu-item.vue"]]); const Hi = { title: String }, Ki = "ElMenuItemGroup", ji = B({ name: Ki, props: Hi, setup() { return { ns: ee("menu-item-group") } } }); function zi(e, t, n, r, o, s) { return k(), Q("li", { class: ne(e.ns.b()) }, [ue("div", { class: ne(e.ns.e("title")) }, [e.$slots.title ? j(e.$slots, "title", { key: 1 }) : (k(), Q($e, { key: 0 }, [vt(De(e.title), 1)], 64))], 2), ue("ul", null, [j(e.$slots, "default")])], 2) } var Jo = q(ji, [["render", zi], ["__file", "menu-item-group.vue"]]); const Ui = Ve(Ni, { MenuItem: Yo, MenuItemGroup: Jo, SubMenu: un }), Wi = Ie(Yo), Gi = Ie(Jo), Vi = Ie(un); function qi() { return { isCollapse: !0 } } const Zo = Cr("counter", () => ({ state: P(qi()) })), Yi = { __name: "CommonAside", setup(e) { const t = P([{ path: "/", name: "home", label: "首页", icon: "house", url: "/" }, { path: "/user", name: "user", label: "用户", icon: "user", url: "User" }, { path: "/game", name: "game", label: "游戏", icon: "trophy", url: "/game" }, { path: "/present", name: "present", label: "礼盒", icon: "present", url: "/present" }, { path: "/help", name: "help", label: "工具", icon: "help", url: "/help" }, { path: "/music", name: "music", label: "音乐", icon: "Headset", url: "/music" }, { label: "小项目", icon: "files", children: [{ path: "/pc", name: "pc", label: "pc端", icon: "monitor", url: "pc" }, { path: "/mobile", name: "mobile", label: "移动端", icon: "iphone", url: "mobile" }] }]), n = w(() => t.value.filter(l => !l.children)), r = w(() => t.value.filter(l => l.children)), o = Zo(), s = w(() => o.state.isCollapse), a = w(() => o.state.isCollapse ? "64px" : "200px"); return (l, i) => { const u = Wi, d = Gi, g = Vi, b = Ui, m = Ml; return k(), Z(m, { width: a.value }, { default: A(() => [K(b, { "default-active": "/home", class: "el-menu-vertical-demo", onOpen: l.handleOpen, onClose: l.handleClose, "text-color": "#fff", "active-text-color": "#ffd04b", "background-color": "#545c64", collapse: s.value, "collapse-transition": !1, router: !0 }, { default: A(() => [Ke(ue("h3", null, "corndream导航页", 512), [[wt, !s.value]]), Ke(ue("h3", null, "导航", 512), [[wt, s.value]]), (k(!0), Q($e, null, Pt(n.value, c => (k(), Z(u, { index: c.path, key: c.path }, { default: A(() => [(k(), Z(He(c.icon), { class: "icons" })), ue("span", null, De(c.label), 1)]), _: 2 }, 1032, ["index"]))), 128)), (k(!0), Q($e, null, Pt(r.value, c => (k(), Z(g, { index: c.path, key: c.path }, { title: A(() => [(k(), Z(He(c.icon), { class: "icons" })), ue("span", null, De(c.label), 1)]), default: A(() => [K(d, null, { default: A(() => [(k(!0), Q($e, null, Pt(c.children, f => (k(), Z(u, { index: f.path, key: f.path }, { default: A(() => [(k(), Z(He(f.icon), { class: "icons" })), ue("span", null, De(f.label), 1)]), _: 2 }, 1032, ["index"]))), 128))]), _: 2 }, 1024)]), _: 2 }, 1032, ["index"]))), 128))]), _: 1 }, 8, ["onOpen", "onClose", "collapse"])]), _: 1 }, 8, ["width"]) } } }, Ji = Kt(Yi, [["__scopeId", "data-v-99891a87"]]), Zi = { class: "header" }, Xi = { class: "l-c" }, Qi = { class: "r-c" }, eu = { class: "el-dropdown-link userbox" }, tu = ["src"], nu = { __name: "CommonHeader", setup(e) { const t = Zo(), n = o => new URL(Object.assign({ "../assets/images/1000.png": Ar, "../assets/images/8946.png_300.png": Fr, "../assets/images/user.png": Nr })[`../assets/images/${o}.png`], import.meta.url).href, r = () => { t.state.isCollapse = !t.state.isCollapse }; return (o, s) => { const a = jt, l = dl, i = cl, u = Ci, d = Ii, g = Ei; return k(), Q("div", Zi, [ue("div", Xi, [K(a, { size: "small", onClick: r }, { default: A(() => [(k(), Z(He("menu"), { class: "icons" }))]), _: 1 }), K(i, { separator: "/", class: "bread" }, { default: A(() => [K(l, { to: { path: "/" }, class: "breadcrumb", "text-color": "#fff" }, { default: A(() => [vt("首页")]), _: 1 })]), _: 1 })]), ue("div", Qi, [K(g, null, { dropdown: A(() => [K(d, null, { default: A(() => [K(u, null, { default: A(() => [vt("个人中心")]), _: 1 }), K(u, null, { default: A(() => [vt("退出")]), _: 1 })]), _: 1 })]), default: A(() => [ue("span", eu, [ue("img", { src: n("user"), alt: "", class: "user" }, null, 8, tu)])]), _: 1 })])]) } } }, ou = Kt(nu, [["__scopeId", "data-v-7ee305dd"]]), ru = { class: "commom-layout" }, su = { __name: "Main", setup(e) { return (t, n) => { const r = $l, o = re("router-view"), s = to, a = Pl, l = Sl; return k(), Q("div", ru, [K(l, { class: "ay-container" }, { default: A(() => [K(Ji, { class: "CommonAside", ref: "hig" }, null, 512), K(l, null, { default: A(() => [K(r, { class: "el-header" }, { default: A(() => [K(ou)]), _: 1 }), K(a, { class: "right-main" }, { default: A(() => [K(s, { height: "900px" }, { default: A(() => [K(o)]), _: 1 })]), _: 1 })]), _: 1 })]), _: 1 })]) } } }, mu = Kt(su, [["__scopeId", "data-v-3aef9670"]]); export { mu as default };
